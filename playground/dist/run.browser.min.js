var Run = (function(t) {
  var e = {};
  function r(n) {
    if (e[n]) return e[n].exports;
    var o = (e[n] = { i: n, l: !1, exports: {} });
    return t[n].call(o.exports, o, o.exports, r), (o.l = !0), o.exports;
  }
  return (
    (r.m = t),
    (r.c = e),
    (r.d = function(t, e, n) {
      r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n });
    }),
    (r.r = function(t) {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(t, '__esModule', { value: !0 });
    }),
    (r.t = function(t, e) {
      if ((1 & e && (t = r(t)), 8 & e)) return t;
      if (4 & e && 'object' == typeof t && t && t.__esModule) return t;
      var n = Object.create(null);
      if (
        (r.r(n),
        Object.defineProperty(n, 'default', { enumerable: !0, value: t }),
        2 & e && 'string' != typeof t)
      )
        for (var o in t)
          r.d(
            n,
            o,
            function(e) {
              return t[e];
            }.bind(null, o)
          );
      return n;
    }),
    (r.n = function(t) {
      var e =
        t && t.__esModule
          ? function() {
              return t.default;
            }
          : function() {
              return t;
            };
      return r.d(e, 'a', e), e;
    }),
    (r.o = function(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (r.p = ''),
    r((r.s = 1))
  );
})([
  function(t, e, r) {
    'use strict';
    var n = r(4),
      o = r(18),
      s = Object.prototype.toString;
    function i(t) {
      return '[object Array]' === s.call(t);
    }
    function a(t) {
      return null !== t && 'object' == typeof t;
    }
    function c(t) {
      return '[object Function]' === s.call(t);
    }
    function u(t, e) {
      if (null != t)
        if (('object' != typeof t && (t = [t]), i(t)))
          for (var r = 0, n = t.length; r < n; r++) e.call(null, t[r], r, t);
        else
          for (var o in t)
            Object.prototype.hasOwnProperty.call(t, o) &&
              e.call(null, t[o], o, t);
    }
    t.exports = {
      isArray: i,
      isArrayBuffer: function(t) {
        return '[object ArrayBuffer]' === s.call(t);
      },
      isBuffer: o,
      isFormData: function(t) {
        return 'undefined' != typeof FormData && t instanceof FormData;
      },
      isArrayBufferView: function(t) {
        return 'undefined' != typeof ArrayBuffer && ArrayBuffer.isView
          ? ArrayBuffer.isView(t)
          : t && t.buffer && t.buffer instanceof ArrayBuffer;
      },
      isString: function(t) {
        return 'string' == typeof t;
      },
      isNumber: function(t) {
        return 'number' == typeof t;
      },
      isObject: a,
      isUndefined: function(t) {
        return void 0 === t;
      },
      isDate: function(t) {
        return '[object Date]' === s.call(t);
      },
      isFile: function(t) {
        return '[object File]' === s.call(t);
      },
      isBlob: function(t) {
        return '[object Blob]' === s.call(t);
      },
      isFunction: c,
      isStream: function(t) {
        return a(t) && c(t.pipe);
      },
      isURLSearchParams: function(t) {
        return (
          'undefined' != typeof URLSearchParams && t instanceof URLSearchParams
        );
      },
      isStandardBrowserEnv: function() {
        return (
          ('undefined' == typeof navigator ||
            ('ReactNative' !== navigator.product &&
              'NativeScript' !== navigator.product &&
              'NS' !== navigator.product)) &&
          ('undefined' != typeof window && 'undefined' != typeof document)
        );
      },
      forEach: u,
      merge: function t() {
        var e = {};
        function r(r, n) {
          'object' == typeof e[n] && 'object' == typeof r
            ? (e[n] = t(e[n], r))
            : (e[n] = r);
        }
        for (var n = 0, o = arguments.length; n < o; n++) u(arguments[n], r);
        return e;
      },
      deepMerge: function t() {
        var e = {};
        function r(r, n) {
          'object' == typeof e[n] && 'object' == typeof r
            ? (e[n] = t(e[n], r))
            : (e[n] = 'object' == typeof r ? t({}, r) : r);
        }
        for (var n = 0, o = arguments.length; n < o; n++) u(arguments[n], r);
        return e;
      },
      extend: function(t, e, r) {
        return (
          u(e, function(e, o) {
            t[o] = r && 'function' == typeof e ? n(e, r) : e;
          }),
          t
        );
      },
      trim: function(t) {
        return t.replace(/^\s*/, '').replace(/\s*$/, '');
      }
    };
  },
  function(t, e, r) {
    (function(e) {
      const n = r(14),
        o = r(35),
        s = r(13),
        { Purse: i } = r(43),
        a = r(2),
        { Address: c, PrivateKey: u, PublicKey: h } = a;
      class f {
        constructor(t = {}) {
          (this.version = '0.3.2-alpha'),
            (this.network = t.network || 'main'),
            (this.bsvNetwork = 'main' === this.network ? 'mainnet' : 'testnet'),
            (this.sandbox = t.sandbox || !0);
          const e = typeof t.app;
          if ('undefined' !== e && 'string' !== e)
            throw new Error('app must be a string');
          (this.app = t.app || ''), this.pb();
          try {
            const e = new u(t.owner, this.bsvNetwork);
            if (t.owner && e.toString() !== t.owner.toString())
              throw new Error();
            this.owner = {
              privkey: e,
              pubkey: e.publicKey,
              address: e.toAddress()
            };
          } catch (e) {
            if ('Private key network mismatch' === e.message) throw e;
            try {
              const e = new h(t.owner, this.bsvNetwork);
              this.owner = { pubkey: e, address: e.toAddress() };
            } catch (e) {
              try {
                this.owner = { address: new c(t.owner, this.bsvNetwork) };
              } catch (e) {
                if ('Address has mismatched network type.' === e.message)
                  throw e;
                throw new Error(`invalid owner: ${t.owner}`);
              }
            }
          }
          (this.owner.jigs = []),
            (this.owner.code = []),
            (this.owner.utxos = []),
            'string' == typeof t.blockchain
              ? (this.blockchain = new n(this.network, t.blockchain))
              : (this.blockchain = t.blockchain || new n(this.network)),
            'string' == typeof t.purse ||
            void 0 === t.purse ||
            t.purse instanceof u ||
            null === t.purse
              ? (this.purse = new i(
                  new u(t.purse, this.bsvNetwork),
                  this.blockchain
                ))
              : (this.purse = t.purse),
            (this.sa = new s(this)),
            'mock' === this.network &&
              this.blockchain.fund(this.purse.address, 1e8),
            this.activate(),
            this.sync();
        }
        async sync() {
          await this.sa.sync();
          const t = async () => {
            const t = new c(this.owner.address, this.bsvNetwork).toString(),
              e = await this.blockchain.utxos(t);
            if (
              e.length !== this.owner.utxos.length ||
              this.owner.utxos.some(
                t => !e.some(e => t.txid === e.txid && t.vout === e.vout)
              )
            ) {
              const t = [],
                r = [],
                n = await Promise.all(
                  e.map(t => this.blockchain.fetch(t.txid))
                );
              for (let o = 0; o < e.length; o++) {
                const i = e[o],
                  a = s.ku(n[o], i.vout);
                if ('jig' === a)
                  try {
                    const e = await this.load(`${i.txid}_o${i.vout}`);
                    t.push(e);
                  } catch (t) {}
                else if ('def' === a)
                  try {
                    const t = await this.load(`${i.txid}_o${i.vout}`);
                    r.push(t);
                  } catch (t) {}
              }
              this.owner.jigs.forEach(e => {
                try {
                  e.location.startsWith('_') && t.push(e);
                } catch (r) {
                  t.push(e);
                }
              }),
                this.owner.code.forEach(t => {
                  try {
                    t.location.startsWith('_') && r.push(t);
                  } catch (e) {
                    r.push(t);
                  }
                }),
                (this.owner.utxos = e),
                (this.owner.jigs = t),
                (this.owner.Code = r);
            }
          };
          return (
            this.updateOwner ||
              (this.updateOwner = new Promise((e, r) => {
                t()
                  .then(e)
                  .catch(r);
              }).finally(() => {
                this.updateOWner = null;
              })),
            this.updateOwner
          );
        }
        _onRefs(t, e) {
          t.forEach(t => {
            t.owner === this.owner.pubkey.toString()
              ? this.owner.code.includes(t) || this.owner.code.push(t)
              : this.owner.code.includes(t) &&
                (this.owner.code = this.owner.code.filter(e => t !== e));
          }),
            e.forEach(t => {
              t.owner === this.owner.pubkey.toString()
                ? this.owner.jigs.includes(t) || this.owner.jigs.push(t)
                : this.owner.jigs.includes(t) &&
                  (this.owner.jigs = this.owner.jigs.filter(e => t !== e));
            });
        }
        _onBroadcastTransaction(t) {
          (this.owner.utxos = this.owner.utxos.filter(
            e =>
              !t.inputs.some(
                t =>
                  e.txid === t.prevTxId.toString('hex') &&
                  e.vout === t.outputIndex
              )
          )),
            t.outputs.forEach((e, r) => {
              e.script.toAddress(this.bsvNetwork).toString() ===
                this.owner.address.toString() &&
                this.owner.utxos.push({
                  txid: t.hash,
                  vout: r,
                  script: e.script,
                  satoshis: e.satoshis
                });
            });
        }
        beginTransaction() {
          return this.sa.begin(), this;
        }
        endTransaction() {
          return this.sa.end(), this;
        }
        async deploy(t) {
          return (
            this.checkActive(), f.code.deploy(t), await this.sync(), t.location
          );
        }
        async load(t) {
          return this.checkActive(), this.sa.load(t);
        }
        checkActive() {
          if (f.instance !== this)
            throw new Error(
              'run instance is not active. call run.activate() first.'
            );
        }
        activate() {
          return (
            (f.instance = this),
            (a.Networks.defaultNetwork = this.bsvNetwork),
            f.code.activate(this.network),
            this
          );
        }
        async gg(t) {
          return this.owner.privkey && t.sign(this.owner.privkey), t;
        }
        pb() {
          a.Networks.defaultNetwork = this.bsvNetwork;
          const t = a.Transaction.prototype.sign;
          a.Transaction.prototype.sign = function(...e) {
            const r = a.Transaction.Input.prototype.isValidSignature;
            a.Transaction.Input.prototype.isValidSignature = () => !0;
            const n = t.call(this, ...e);
            return (a.Transaction.Input.prototype.isValidSignature = r), n;
          };
        }
      }
      let l = null;
      Object.defineProperty(f, 'code', { get: () => (l || (l = new o()), l) });
      const p = { configurable: !0, enumerable: !0 };
      Object.defineProperty(f, 'Jig', { ...p, get: () => f.code.Jig }),
        Object.defineProperty(f, 'Token', { ...p, get: () => r(44) }),
        Object.defineProperty(e, 'Jig', { ...p, get: () => f.Jig }),
        Object.defineProperty(e, 'Token', { ...p, get: () => f.Token }),
        (t.exports = f);
    }.call(this, r(3)));
  },
  function(t, e) {
    t.exports = bsv;
  },
  function(t, e) {
    var r;
    r = (function() {
      return this;
    })();
    try {
      r = r || new Function('return this')();
    } catch (t) {
      'object' == typeof window && (r = window);
    }
    t.exports = r;
  },
  function(t, e, r) {
    'use strict';
    t.exports = function(t, e) {
      return function() {
        for (var r = new Array(arguments.length), n = 0; n < r.length; n++)
          r[n] = arguments[n];
        return t.apply(e, r);
      };
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(0);
    function o(t) {
      return encodeURIComponent(t)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/g, '$')
        .replace(/%2C/gi, ',')
        .replace(/%20/g, '+')
        .replace(/%5B/gi, '[')
        .replace(/%5D/gi, ']');
    }
    t.exports = function(t, e, r) {
      if (!e) return t;
      var s;
      if (r) s = r(e);
      else if (n.isURLSearchParams(e)) s = e.toString();
      else {
        var i = [];
        n.forEach(e, function(t, e) {
          null != t &&
            (n.isArray(t) ? (e += '[]') : (t = [t]),
            n.forEach(t, function(t) {
              n.isDate(t)
                ? (t = t.toISOString())
                : n.isObject(t) && (t = JSON.stringify(t)),
                i.push(o(e) + '=' + o(t));
            }));
        }),
          (s = i.join('&'));
      }
      if (s) {
        var a = t.indexOf('#');
        -1 !== a && (t = t.slice(0, a)),
          (t += (-1 === t.indexOf('?') ? '?' : '&') + s);
      }
      return t;
    };
  },
  function(t, e, r) {
    'use strict';
    t.exports = function(t) {
      return !(!t || !t.__CANCEL__);
    };
  },
  function(t, e, r) {
    'use strict';
    (function(e) {
      var n = r(0),
        o = r(24),
        s = { 'Content-Type': 'application/x-www-form-urlencoded' };
      function i(t, e) {
        !n.isUndefined(t) &&
          n.isUndefined(t['Content-Type']) &&
          (t['Content-Type'] = e);
      }
      var a,
        c = {
          adapter: (void 0 !== e &&
          '[object process]' === Object.prototype.toString.call(e)
            ? (a = r(8))
            : 'undefined' != typeof XMLHttpRequest && (a = r(8)),
          a),
          transformRequest: [
            function(t, e) {
              return (
                o(e, 'Accept'),
                o(e, 'Content-Type'),
                n.isFormData(t) ||
                n.isArrayBuffer(t) ||
                n.isBuffer(t) ||
                n.isStream(t) ||
                n.isFile(t) ||
                n.isBlob(t)
                  ? t
                  : n.isArrayBufferView(t)
                  ? t.buffer
                  : n.isURLSearchParams(t)
                  ? (i(e, 'application/x-www-form-urlencoded;charset=utf-8'),
                    t.toString())
                  : n.isObject(t)
                  ? (i(e, 'application/json;charset=utf-8'), JSON.stringify(t))
                  : t
              );
            }
          ],
          transformResponse: [
            function(t) {
              if ('string' == typeof t)
                try {
                  t = JSON.parse(t);
                } catch (t) {}
              return t;
            }
          ],
          timeout: 0,
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          maxContentLength: -1,
          validateStatus: function(t) {
            return t >= 200 && t < 300;
          }
        };
      (c.headers = { common: { Accept: 'application/json, text/plain, */*' } }),
        n.forEach(['delete', 'get', 'head'], function(t) {
          c.headers[t] = {};
        }),
        n.forEach(['post', 'put', 'patch'], function(t) {
          c.headers[t] = n.merge(s);
        }),
        (t.exports = c);
    }.call(this, r(23)));
  },
  function(t, e, r) {
    'use strict';
    var n = r(0),
      o = r(25),
      s = r(5),
      i = r(27),
      a = r(28),
      c = r(9);
    t.exports = function(t) {
      return new Promise(function(e, u) {
        var h = t.data,
          f = t.headers;
        n.isFormData(h) && delete f['Content-Type'];
        var l = new XMLHttpRequest();
        if (t.auth) {
          var p = t.auth.username || '',
            d = t.auth.password || '';
          f.Authorization = 'Basic ' + btoa(p + ':' + d);
        }
        if (
          (l.open(
            t.method.toUpperCase(),
            s(t.url, t.params, t.paramsSerializer),
            !0
          ),
          (l.timeout = t.timeout),
          (l.onreadystatechange = function() {
            if (
              l &&
              4 === l.readyState &&
              (0 !== l.status ||
                (l.responseURL && 0 === l.responseURL.indexOf('file:')))
            ) {
              var r =
                  'getAllResponseHeaders' in l
                    ? i(l.getAllResponseHeaders())
                    : null,
                n = {
                  data:
                    t.responseType && 'text' !== t.responseType
                      ? l.response
                      : l.responseText,
                  status: l.status,
                  statusText: l.statusText,
                  headers: r,
                  config: t,
                  request: l
                };
              o(e, u, n), (l = null);
            }
          }),
          (l.onabort = function() {
            l && (u(c('Request aborted', t, 'ECONNABORTED', l)), (l = null));
          }),
          (l.onerror = function() {
            u(c('Network Error', t, null, l)), (l = null);
          }),
          (l.ontimeout = function() {
            u(
              c('timeout of ' + t.timeout + 'ms exceeded', t, 'ECONNABORTED', l)
            ),
              (l = null);
          }),
          n.isStandardBrowserEnv())
        ) {
          var g = r(29),
            w =
              (t.withCredentials || a(t.url)) && t.xsrfCookieName
                ? g.read(t.xsrfCookieName)
                : void 0;
          w && (f[t.xsrfHeaderName] = w);
        }
        if (
          ('setRequestHeader' in l &&
            n.forEach(f, function(t, e) {
              void 0 === h && 'content-type' === e.toLowerCase()
                ? delete f[e]
                : l.setRequestHeader(e, t);
            }),
          t.withCredentials && (l.withCredentials = !0),
          t.responseType)
        )
          try {
            l.responseType = t.responseType;
          } catch (e) {
            if ('json' !== t.responseType) throw e;
          }
        'function' == typeof t.onDownloadProgress &&
          l.addEventListener('progress', t.onDownloadProgress),
          'function' == typeof t.onUploadProgress &&
            l.upload &&
            l.upload.addEventListener('progress', t.onUploadProgress),
          t.cancelToken &&
            t.cancelToken.promise.then(function(t) {
              l && (l.abort(), u(t), (l = null));
            }),
          void 0 === h && (h = null),
          l.send(h);
      });
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(26);
    t.exports = function(t, e, r, o, s) {
      var i = new Error(t);
      return n(i, e, r, o, s);
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(0);
    t.exports = function(t, e) {
      e = e || {};
      var r = {};
      return (
        n.forEach(['url', 'method', 'params', 'data'], function(t) {
          void 0 !== e[t] && (r[t] = e[t]);
        }),
        n.forEach(['headers', 'auth', 'proxy'], function(o) {
          n.isObject(e[o])
            ? (r[o] = n.deepMerge(t[o], e[o]))
            : void 0 !== e[o]
            ? (r[o] = e[o])
            : n.isObject(t[o])
            ? (r[o] = n.deepMerge(t[o]))
            : void 0 !== t[o] && (r[o] = t[o]);
        }),
        n.forEach(
          [
            'baseURL',
            'transformRequest',
            'transformResponse',
            'paramsSerializer',
            'timeout',
            'withCredentials',
            'adapter',
            'responseType',
            'xsrfCookieName',
            'xsrfHeaderName',
            'onUploadProgress',
            'onDownloadProgress',
            'maxContentLength',
            'validateStatus',
            'maxRedirects',
            'httpAgent',
            'httpsAgent',
            'cancelToken',
            'socketPath'
          ],
          function(n) {
            void 0 !== e[n] ? (r[n] = e[n]) : void 0 !== t[n] && (r[n] = t[n]);
          }
        ),
        r
      );
    };
  },
  function(t, e, r) {
    'use strict';
    function n(t) {
      this.message = t;
    }
    (n.prototype.toString = function() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    }),
      (n.prototype.__CANCEL__ = !0),
      (t.exports = n);
  },
  function(t, e, r) {
    function n(t) {
      return (
        'function' == typeof t &&
        (/^class [A-Za-z0-9_]/.test(t.toString()) ||
          /^function [A-Za-z0-9_]/.test(t.toString())) &&
        -1 === t.toString().indexOf('[native code]')
      );
    }
    const o = ' abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890-=~!@#$%^&*()_+,./;\'[]\\<>?:"{}|'.split(
        ''
      ),
      s = 't08sY]m\'#$Dy1`}pCKrHG)f9[uq%3\\ha=!ZVMkJ-*L"xz67R? W~@wdO:Ecg|ITe52.+{ovBj>(&,/Q4lA;^<NPnXSFi_Ub'.split(
        ''
      );
    t.exports = {
      code: function(t) {
        const e = t.toString(),
          r = Object.getPrototypeOf(t);
        if (r.prototype) {
          const n = /^class .+ extends .+ {/;
          return e.replace(n, `class ${t.name} extends ${r.name} {`);
        }
        return e;
      },
      dy: n,
      nt: function(t) {
        return t
          .split('')
          .map(t => (-1 !== o.indexOf(t) ? s[o.indexOf(t)] : t))
          .join('');
      },
      et: function(t) {
        return t
          .split('')
          .map(t => (-1 !== s.indexOf(t) ? o[s.indexOf(t)] : t))
          .join('');
      },
      ppp: function t(e, r = [], n = null, o = null, s = new Set(), i = !1) {
        function a() {
          let t = `cannot pack ${typeof e}${n ? ' ' + n : ''}`;
          try {
            t = `cannot pack ${typeof e}${n ? ' ' + n : ''}: ${e.toString()}`;
          } catch (t) {}
          throw new Error(t);
        }
        if (null === e) return null;
        if ('number' == typeof e) return (!isNaN(e) && isFinite(e)) || a(), e;
        if ('string' == typeof e || 'boolean' == typeof e) return e;
        if (void 0 === e) return { __class: 'undefined' };
        for (const i of r) {
          const a = i(e, o, n);
          if (a) return t(a, r, n, o, s, !0);
        }
        if (
          (('function' != typeof e && 'symbol' != typeof e) || a(),
          'object' == typeof e)
        ) {
          if (!i && void 0 !== e.__class)
            throw new Error('__class must not be defined');
          if (s.has(e)) throw new Error('cannot pack duplicate object');
          s.add(e);
          const n = Object.getPrototypeOf(Object.getPrototypeOf(e));
          if (null === n) {
            const n = {};
            return (
              Object.keys(e).forEach(o => {
                n[o] = t(e[o], r, o, e, s);
              }),
              n
            );
          }
          if (Array.isArray(e) && null === Object.getPrototypeOf(n)) {
            const n = new Array(e.length);
            return (
              Object.keys(e).forEach(o => {
                n[o] = t(e[o], r, o, e, s);
              }),
              n
            );
          }
          a();
        }
      },
      unppp: function t(e, r = [], n = null, o = null) {
        if (null === e) return null;
        if ('number' == typeof e) {
          if (isNaN(e) || !isFinite(e))
            throw new Error(`cannot unpack number ${e}`);
          return e;
        }
        if ('string' == typeof e || 'boolean' == typeof e) return e;
        for (const t of r) {
          const r = t(e, o, n);
          if (r) return r;
        }
        if ('object' == typeof e) {
          if ('undefined' === e.__class) return;
          if (void 0 !== e.__class)
            throw new Error(`unexpected class ${e.__class}`);
          const n = Object.getPrototypeOf(Object.getPrototypeOf(e));
          if (null === n) {
            const n = {};
            return (
              Object.keys(e).forEach(o => {
                n[o] = t(e[o], r, o, e);
              }),
              n
            );
          }
          if (Array.isArray(e) && null === Object.getPrototypeOf(n)) {
            const n = new Array(e.length);
            return (
              Object.keys(e).forEach(o => {
                n[o] = t(e[o], r, o, e);
              }),
              n
            );
          }
        }
        throw new Error(`cannot unpack ${typeof e}`);
      },
      jrp: function(Jig, t = [], e = !1) {
        return (r, n, o) => {
          if ('object' == typeof r && r instanceof Jig)
            return e && !n
              ? { ...r }
              : (t.push(r), { __class: 'ref', ref: t.length - 1 });
        };
      },
      crp: function(t = [], e) {
        return (r, o, s) => {
          if (n(r))
            return t.push(r), e && e(r), { __class: 'ref', ref: t.length - 1 };
        };
      },
      rfu: function(t) {
        return (e, r, n) => {
          if ('ref' === e.__class) return t[e.ref];
        };
      },
      dsa: function(t, e) {
        return JSON.stringify(t) !== JSON.stringify(e);
      },
      run: function() {
        const t = r(1);
        if (!t.instance) throw new Error('Run not instantiated');
        return t.instance;
      }
    };
  },
  function(t, e, r) {
    (function(e) {
      const n = r(2),
        { code: o, dy: s, nt: i, et: a, ppp: c, unppp: u, rfu: h } = r(12),
        f = (t, e) =>
          t === e || (t.origin && '_' !== t.origin[0] && t.origin === e.origin);
      t.exports = class {
        constructor(t) {
          (this.run = t),
            (this.blockchain = t.blockchain),
            (this.owner = t.owner.pubkey ? t.owner.pubkey.toString() : null),
            (this.code = t.constructor.code),
            (this.bsvNetwork = t.bsvNetwork),
            (this.pay = (...e) => t.purse.pay(...e)),
            (this.sign = (...e) => t.gg(...e)),
            (this.protoTx = this.newProtoTx()),
            (this.eg = []),
            (this.syncListeners = []),
            (this.beginCount = 0),
            (this.lastPosted = new Map()),
            (this.maxSatoshis = 1e8),
            (this.onBroadcastListeners = new Set());
        }
        newProtoTx() {
          return {
            actions: [],
            defs: [],
            stateBefore: new Map(),
            stateAfter: new Map(),
            inputs: [],
            outputs: [],
            ea: new Set(),
            oe: new Map()
          };
        }
        kw(t) {
          if ('string' != typeof t)
            throw new Error('owner must be a pubkey string');
          try {
            new n.PublicKey(t, { network: this.bsvNetwork });
          } catch (t) {
            throw new Error(`owner is not a valid public key\n\n${t}`);
          }
        }
        ks(t) {
          if ('number' != typeof t)
            throw new Error('satoshis must be a number');
          if (isNaN(t) || !isFinite(t))
            throw new Error('satoshis must be finite');
          if (t < 0) throw new Error('satoshis must be non-negative');
          if (t > this.maxSatoshis)
            throw new Error(`satoshis must be less than ${this.maxSatoshis}`);
        }
        begin() {
          this.beginCount++;
        }
        end() {
          if (0 === this.beginCount) throw new Error('end sa without begin');
          0 == --this.beginCount &&
            (this.eg.push(this.protoTx),
            (this.protoTx = this.newProtoTx()),
            1 === this.eg.length && this.liNext().catch(t => {}));
        }
        storeDefinition(t, e, r, n, o) {
          this.begin();
          try {
            if (this.eg.some(e => e.defs.some(e => e.type === t))) return;
            return (
              this.protoTx.defs.push({
                type: t,
                deps: e,
                props: r,
                success: n,
                error: o,
                owner: this.owner
              }),
              {
                tempLocation: `_d${this.protoTx.defs.length - 1}`,
                owner: this.owner
              }
            );
          } finally {
            this.end();
          }
        }
        storeAction(t, e, r, n, o, s, i, a, c) {
          this.begin();
          try {
            const u = new Map(),
              h = t => {
                const e = t => void 0 !== t.origin && '_' !== t.origin[0],
                  r = u.get(e(t) ? t.origin : t);
                if (!r) return u.set(e(t) ? t.origin : t, t.location);
                if (r !== t.location)
                  throw new Error(
                    `referenced different locations of same jig: ${t}`
                  );
              };
            h(t),
              n.forEach(t => h(t)),
              o.forEach(t => h(t)),
              s.forEach(t => h(t)),
              i.forEach((t, e) => {
                this.protoTx.stateBefore.set(
                  e,
                  this.protoTx.stateBefore.get(e) || t
                );
              }),
              a.forEach((t, e) => {
                this.protoTx.stateAfter.set(e, t);
              }),
              n.forEach(t => {
                if (
                  this.protoTx.inputs.some(
                    e => f(t, e) && e.location !== t.location
                  )
                )
                  throw new Error('different instances of the same jig');
                this.protoTx.inputs.some(e => f(t, e)) ||
                  this.protoTx.inputs.push(t);
              }),
              o.forEach(t => {
                const e = this.protoTx.outputs.findIndex(e => f(t, e));
                if (-1 !== e)
                  return (
                    (t.location = `_o${e}`),
                    void (t.origin || (t.origin = t.location))
                  );
                this.protoTx.outputs.push(t);
                (t =>
                  t.origin &&
                  '_' !== t.origin[0] &&
                  t.location &&
                  '_' !== t.location[0] &&
                  !this.lastPosted.has(t.origin))(t) &&
                  this.lastPosted.set(t.origin, t.location),
                  (t.location = `_o${this.protoTx.outputs.length - 1}`),
                  t.origin || (t.origin = t.location);
              }),
              s.forEach(t => this.protoTx.ea.add(t)),
              c.forEach((t, e) => this.protoTx.oe.set(e, t));
            const l = i.get(t).value.owner;
            this.protoTx.actions.push({
              source: t,
              method: e,
              creator: l,
              args: r,
              inputs: n,
              outputs: o,
              ea: s
            });
          } finally {
            this.end();
          }
        }
        async liNext() {
          if (this.verify) return;
          const t = this.eg[0];
          if (!t.actions.length && !t.defs.length) return this.finish();
          let a = null;
          try {
            const l = t.inputs.filter(t => '_' !== t.origin[0]),
              p = new Map();
            t.ea.forEach(e => {
              if (l.includes(e) || t.outputs.includes(e)) return;
              const r = this.lastPosted.get(e.origin) || e.location,
                n = p.get(e.origin);
              if (n && n !== r)
                throw new Error(
                  `read different locations of same jig ${e.origin}`
                );
              p.set(e.origin, r);
            });
            const d = Array.from(p.values()),
              { Jig: Jig } = r(1),
              g = (e, r, n) => {
                if ('object' == typeof e && e instanceof Jig) {
                  const r = Array.from(t.oe.entries())
                    .filter(([t, r]) => r === e)
                    .map(([t, e]) => t);
                  r.length && (e = r[0]);
                  const n = l.findIndex(t => f(t, e));
                  if (-1 !== n) return { __class: 'ref', id: `_i${n}` };
                  const o = t.outputs.findIndex(t => f(t, e));
                  if (-1 !== o)
                    return { __class: 'ref', id: `_o${1 + t.defs.length + o}` };
                  const s = d.indexOf(p.get(e.origin));
                  return -1 !== s
                    ? { __class: 'ref', id: `_r${s}` }
                    : {
                        __class: 'ref',
                        id: this.lastPosted.get(e.origin) || e.location
                      };
                }
              },
              w =
                'main' === this.run.network
                  ? 'Mainnet'
                  : 'test' === this.run.network
                  ? 'Testnet'
                  : 'stn' === this.run.network
                  ? 'Stn'
                  : 'Mocknet',
              y = (t, e, r) => {
                if (s(t)) {
                  return {
                    __class: 'ref',
                    id:
                      '_' === t[`location${w}`][0]
                        ? `_o${parseInt(t[`location${w}`].slice(2)) + 1}`
                        : t[`location${w}`]
                  };
                }
              },
              b = {
                actions: t.actions.map(e => {
                  const { method: r } = e,
                    n = c(e.args, [g, y]);
                  if ('init' === e.method) {
                    const t =
                      e.source.constructor[`origin${w}`] ||
                      e.source.constructor[`location${w}`];
                    return {
                      def: '_' === t[0] ? `_o${1 + parseInt(t.slice(2))}` : t,
                      creator: e.creator,
                      method: r,
                      args: n
                    };
                  }
                  const o = l.findIndex(t => f(t, e.source));
                  if (-1 !== o) return { source: `_i${o}`, method: r, args: n };
                  const s = t.outputs.findIndex(t => f(t, e.source));
                  return -1 !== s
                    ? {
                        source: `_o${1 + t.defs.length + s}`,
                        method: r,
                        args: n
                      }
                    : {
                        source:
                          '_' !== e.source.location[0]
                            ? e.source.location
                            : this.lastPosted.get(e.source.origin),
                        method: r,
                        args: n
                      };
                }),
                defs: t.defs.map(t => {
                  const e = t =>
                      '_' === t[0] ? `_o${1 + parseInt(t.slice(2))}` : t,
                    r = Object.entries(t.deps).map(([t, r]) => ({
                      [t]: e(r[`location${w}`])
                    })),
                    n = r.length ? Object.assign(...r) : void 0;
                  let s;
                  return (
                    Object.keys(t.props).length && (s = c(t.props, [g, y])),
                    { code: o(t.type), deps: n, props: s, owner: t.owner }
                  );
                }),
                jigs: t.outputs.length,
                refs: d.length ? d : void 0
              },
              m = JSON.stringify(b);
            this.run._onRefs(t.defs.map(t => t.type), t.outputs);
            const v = i(m),
              x = e.from('run', 'utf8'),
              E = e.from([0], 'hex'),
              k = e.from(this.run.app, 'utf8'),
              _ = e.from(v, 'utf8'),
              S = e.from('r16o', 'utf8'),
              T = n.Script.buildSafeDataOut([x, E, k, _, S]);
            a = new n.Transaction().addOutput(
              new n.Transaction.Output({ script: T, satoshis: 0 })
            );
            const A = d.map(t => t.slice(0, 64)),
              O = d.map(t => parseInt(t.slice(66)));
            (await Promise.all(A.map(t => this.blockchain.fetch(t)))).forEach(
              (t, e) => {
                if (void 0 === t.outputs[O[e]].spentTxId)
                  throw new Error(
                    `Read ${
                      d[e]
                    } may not be latest. Blockchain did not return spentTxId. Aborting.`
                  );
                if (null !== t.outputs[O[e]].spentTxId)
                  throw new Error(
                    `Read ${d[e]} is not the latest. Must sync() jigs`
                  );
              }
            );
            const P = l.map(t => this.lastPosted.get(t.origin) || t.location),
              $ = await Promise.all(
                P.map(t => this.blockchain.fetch(t.slice(0, 64)))
              );
            l.forEach((t, e) => {
              const r = P[e].slice(0, 64),
                n = parseInt(P[e].slice(66)),
                o = $[e].outputs[n],
                s = {
                  txid: r,
                  vout: n,
                  script: o.script,
                  satoshis: o.satoshis
                };
              a.from(s);
            });
            const R = t =>
              new n.PublicKey(t.owner, { network: this.bsvNetwork });
            t.defs.forEach(t => a.to(R(t), n.Transaction.DUST_AMOUNT)),
              t.outputs.forEach(e => {
                const r = t.stateAfter.get(e).value.owner,
                  o = new n.PublicKey(r, {
                    network: this.bsvNetwork
                  }).toAddress(),
                  s = t.stateAfter.get(e).value.satoshis;
                a.to(o, Math.max(n.Transaction.DUST_AMOUNT, s));
              }),
              (a = await this.pay(a)),
              (a = await this.sign(a));
            for (let t = 0; t < l.length; t++)
              if (!a.inputs[t].isFullySigned())
                throw new Error(
                  `signature missing for ${l[t].constructor.name}\n\norigin: ${
                    l[t].origin
                  }\nlocation: ${P[t]}\nowner: ${l[t].owner}`
                );
            await this.blockchain.broadcast(a),
              this.run._onBroadcastTransaction(a),
              this.onBroadcastListeners.forEach(t => t(a));
          } catch (t) {
            const e = 0 === this.syncListeners.length;
            return (
              this.syncListeners.forEach(e => e.reject(t)),
              (this.syncListeners = []),
              this.eg.forEach(r => {
                r.defs.forEach(t => t.error()),
                  r.outputs.forEach(n => {
                    if ('_' === n.origin[0] || e) {
                      const e = `!${
                        '_' === n.origin[0]
                          ? 'deploy failed'
                          : 'a previous update failed'
                      }\n\n${t}`;
                      return (
                        Object.keys(n).forEach(t => delete n[t]),
                        void (n.origin = n.location = e)
                      );
                    }
                    if ('_' !== n.location[0]) return;
                    const o = n.origin;
                    Object.keys(n).forEach(t => delete n[t]);
                    const s = [h(r.stateBefore.get(n).refs)];
                    Object.assign(n, u(r.stateBefore.get(n).value, s)),
                      (n.origin = o),
                      (n.location = this.lastPosted.get(o));
                  });
              }),
              (this.eg = []),
              void (this.lastPosted = new Map())
            );
          }
          const l = t =>
            this.eg.slice(1).some(e => e.outputs.some(e => f(t, e)));
          t.outputs.forEach((e, r) => {
            const n = 1 + t.defs.length + r;
            '_' === e.origin[0] && (e.origin = `${a.hash}_o${n}`),
              l(e)
                ? this.lastPosted.set(e.origin, `${a.hash}_o${n}`)
                : ((e.location = `${a.hash}_o${n}`),
                  this.lastPosted.delete(e.origin));
          }),
            t.defs.forEach((t, e) => t.success(`${a.hash}_o${e + 1}`)),
            this.finish();
        }
        async finish() {
          this.eg.shift(),
            this.eg.length
              ? this.liNext()
              : (this.syncListeners.forEach(t => t.resolve()),
                (this.syncListeners = []));
        }
        async load(t) {
          if ('string' != typeof t)
            throw new Error(`typeof location is ${typeof t} - must be string`);
          const e = this.code.al(t);
          if (e) return e;
          const r = t.slice(0, 64),
            n = parseInt(t.slice(66));
          if (isNaN(n)) throw new Error(`bad location: ${t}`);
          const o = await this.blockchain.fetch(r),
            s = this.xtData(o);
          if (n > 0 && n < s.defs.length + 1)
            return this.code.installFromTx(
              s.defs[n - 1],
              t,
              o,
              this.run,
              this.bsvNetwork
            );
          const i = await this.dmt(o, s);
          if (void 0 === i[n]) throw new Error('not a jig output');
          return i[n];
        }
        xtData(t) {
          if (
            !t.outputs.length ||
            !t.outputs[0].script.isSafeDataOut() ||
            7 !== t.outputs[0].script.chunks.length ||
            'run' !== t.outputs[0].script.chunks[2].buf.toString('utf8') ||
            '00' !== t.outputs[0].script.chunks[3].buf.toString('hex')
          )
            throw new Error(`not a run tx: ${t.hash}`);
          const e = t.outputs[0].script.chunks[5].buf.toString('utf8');
          return JSON.parse(a(e));
        }
        async dmt(t, e, o) {
          const s = this.newProtoTx(),
            i = new Map(),
            a = new Map();
          e.refs && e.refs.forEach(t => a.set(t, t));
          for (const r of e.actions) {
            const e = e => {
              if (('_' !== e[0] && a.set(e, e), 'i' === e[1])) {
                const r = t.inputs[parseInt(e.slice(2))];
                a.set(e, `${r.prevTxId.toString('hex')}_o${r.outputIndex}`);
              }
            };
            r.source && e(r.source);
            const n = (t, r, n) => {
              if ('ref' === t.__class) return e(t.id), {};
            };
            u(r.args, [n]);
          }
          for (const [, e] of a) {
            const r = await this.blockchain.fetch(e.slice(0, 64)),
              n = parseInt(e.slice(66));
            if (void 0 === r.outputs[n].spentTxId)
              throw new Error(
                'Cannot check if read is stale. Blockchain API does not support spentTxId.'
              );
            if (null === r.outputs[n].spentTxId) continue;
            const o = await this.blockchain.fetch(r.outputs[n].spentTxId);
            if (
              o.time <= t.time &&
              o.time >= r.time &&
              t.time - r.time > 72e5 &&
              t.hash !== o.hash
            )
              throw new Error(`${e} is stale. Aborting.`);
          }
          for (const [t, e] of a)
            if (o && e === o.location) a.set(t, o);
            else
              try {
                a.set(t, await this.load(e));
              } catch (e) {
                throw new Error(`bad ref ${t}\n\n${e.toString()}`);
              }
          const { Jig: Jig } = r(1),
            h = t => {
              this.code.ed.enforce = !1;
              const e = { ...t };
              c(t, [
                (r, n, o) => {
                  if ('object' == typeof r && r && r instanceof Jig) {
                    if (!n) return e;
                    const s = Array.from(a.values()).find(
                      t => t.origin === r.origin
                    );
                    return (
                      s && n === e && (t[o] = s), s && n !== e && (n[o] = s), {}
                    );
                  }
                }
              ]),
                (this.code.ed.enforce = !0);
            };
          for (const t of a.values()) h(t);
          for (const r of e.actions) {
            const n = (t, r, n) => {
                if ('ref' === t.__class) {
                  if ('_' !== t.id[0] || 'i' === t.id[1]) {
                    const e = a.get(t.id);
                    if (!e) throw new Error(`unexpected ref ${t.id}`);
                    return e;
                  }
                  if ('r' === t.id[1]) {
                    const r = a.get(e.refs[parseInt(t.id.slice(2))]);
                    if (!r) throw new Error(`unexpected ref ${t.id}`);
                    return r;
                  }
                  if ('o' !== t.id[1])
                    throw new Error(`unexpected ref ${t.id}`);
                  const r = parseInt(t.id.slice(2)) - 1 - e.defs.length;
                  return s.oe.get(s.outputs[r]);
                }
              },
              o = u(r.args, [n]);
            if ('init' === r.method) {
              if ('_' === r.def[0]) {
                const t = parseInt(r.def.slice(2));
                if (t <= 0 || t >= e.defs.length + 1)
                  throw new Error(`missing def ${r.def}`);
              }
              const n = await this.load(
                '_' === r.def[0] ? t.hash + r.def : r.def
              );
              this.nv(r.creator, s, i);
              try {
                new n(...o);
              } finally {
                this.dv();
              }
            } else {
              const t =
                a.get(r.source) ||
                s.outputs[parseInt(r.source.slice(2)) - 1 - e.defs.length];
              if ((h(t), void 0 === t))
                throw new Error(`source ${r.source} missing`);
              this.nv(null, s, i);
              try {
                t[r.method](...o);
              } catch (t) {
                throw new Error(`unexpected exception in ${r.method}\n\n${t}`);
              } finally {
                this.dv();
              }
            }
          }
          const f = s.inputs.filter(t => '_' !== t.origin[0]);
          if (e.jigs !== s.outputs.length)
            throw new Error('bad number of jigs');
          if (t.inputs.length < f.length) throw new Error('not enough inputs');
          if (t.outputs.length < e.defs.length + e.jigs + 1)
            throw new Error('not enough outputs');
          f.forEach((e, r) => {
            if (
              `${t.inputs[r].prevTxId.toString('hex')}_o${
                t.inputs[r].outputIndex
              }` !== (i.get(e.origin) || e.location)
            )
              throw new Error(`bad input ${r}`);
          }),
            s.outputs.forEach((r, o) => {
              const s = 1 + e.defs.length + o;
              if (
                new n.PublicKey(r.owner, { network: this.bsvNetwork })
                  .toAddress()
                  .toString() !==
                t.outputs[s].script.toAddress(this.bsvNetwork).toString()
              )
                throw new Error(`bad owner on output ${s}`);
              if (
                t.outputs[s].satoshis <
                Math.max(r.satoshis, n.Transaction.DUST_AMOUNT)
              )
                throw new Error(`bad satoshis on output ${s}`);
            }),
            s.outputs.forEach(r => {
              const n = `${t.hash}_o${1 +
                e.defs.length +
                parseInt(r.location.slice(2))}`;
              '_' === r.origin[0] && (r.origin = n),
                '_' === r.location[0] && (r.location = n);
            });
          const l = s.outputs.map(t => s.oe.get(t));
          return new Array(1 + e.defs.length).concat(l);
        }
        nv(t, e, r) {
          (this.verify = [this.protoTx, this.eg, this.lastPosted, this.owner]),
            (this.protoTx = e),
            (this.eg = [e]),
            (this.lastPosted = r),
            (this.owner = t);
        }
        dv() {
          ([this.protoTx, this.eg, this.lastPosted, this.owner] = this.verify),
            delete this.verify;
        }
        async sync(t = {}) {
          const e = new Set(),
            r = t => e.add(t.hash);
          this.onBroadcastListeners.add(r);
          const n = async () =>
            t.target && (void 0 === t.forward || t.forward)
              ? this.fastForward(t.target, e).then(() => t.target)
              : t.target;
          if (!this.eg.length) return n();
          return new Promise((t, e) => {
            this.syncListeners.push({ resolve: t, reject: e });
          })
            .then(n)
            .catch(t =>
              n().then(() => {
                throw t;
              })
            )
            .finally(() => this.onBroadcastListeners.delete(r));
        }
        async fastForward(t, e = new Set(), n = new Map()) {
          const o = n.get(t.origin);
          if (o)
            return (
              (this.code.ed.enforce = !1),
              Object.assign(t, o),
              (this.code.ed.enforce = !0),
              t
            );
          let i = t.location.slice(0, 64),
            a = parseInt(t.location.slice(66)),
            u = await this.blockchain.fetch(i, !e.has(i));
          for (e.add(i); ; ) {
            const r = u.outputs[a];
            if (void 0 === r.spentTxId) {
              throw new Error(
                `${'Blockchain API does not support forward syncing.'}\n\n${'To just li pending sas, use `jig.sync({ forward: false })`.'}`
              );
            }
            if (null === r.spentTxId) break;
            (u = await this.blockchain.fetch(r.spentTxId, !e.has(i))),
              e.add(r.spentTxId);
            const n = this.xtData(u);
            if (!(await this.dmt(u, n, t)).some(e => e === t))
              throw new Error('jig not found');
            (i = t.location.slice(0, 64)), (a = parseInt(t.location.slice(66)));
          }
          n.set(t.origin, t);
          const h = new Set(),
            { Jig: Jig } = r(1);
          c(t, [
            (t, e, r) => {
              if (t instanceof Jig) return r ? (h.add(t), {}) : { ...t };
            },
            (t, e, r) => {
              if (s(t)) return {};
            }
          ]);
          for (const t of h) await this.fastForward(t, e, n);
        }
        static ku(t, e) {
          if (
            !t.outputs.length ||
            !t.outputs[0].script.isSafeDataOut() ||
            7 !== t.outputs[0].script.chunks.length ||
            'run' !== t.outputs[0].script.chunks[2].buf.toString('utf8') ||
            '00' !== t.outputs[0].script.chunks[3].buf.toString('hex')
          )
            return !1;
          const r = t.outputs[0].script.chunks[5].buf.toString('utf8'),
            n = JSON.parse(a(r)),
            o = e >= 1 && e < 1 + n.defs.length,
            s = e >= 1 + n.defs.length && e < 1 + n.defs.length + n.jigs;
          return o ? 'def' : s ? 'jig' : null;
        }
      };
    }.call(this, r(39).Buffer));
  },
  function(t, e, r) {
    const { starApi: n, bitIndexApi: o, whatsOnChainApi: s, RestApi: i } = r(
        15
      ),
      a = r(34);
    t.exports = class {
      constructor(t, e) {
        if (
          ((e = 'bitindex' === e ? o : 'whatsonchain' === e ? s : n),
          'main' === t)
        )
          return new i(t, e);
        if ('test' === t) return new i(t, e);
        if ('stn' === t) return new i(t, e);
        if ('mock' === t) return new a();
        throw new Error(`Unknown network: ${t}`);
      }
      async broadcast(t) {}
      async fetch(t, e) {}
      async utxos(t) {}
    };
  },
  function(t, e, r) {
    const n = r(16),
      { Address: o, Script: s, Transaction: i } = r(2);
    async function a(t) {
      try {
        return await t;
      } catch (t) {
        const { config: e, response: r } = t;
        if (e && e.url && r && r.data) {
          const t = r.data.message
              ? r.data.message.message || r.data.message
              : r.data,
            n = r.data.name && t ? `${r.data.name}: ${t}` : r.data.name || t;
          throw new Error(`${n}\n\n${e.method.toUpperCase()} ${e.url}`);
        }
        throw t;
      }
    }
    function c(t) {
      const e = new i(t.hex || t.rawtx);
      return (
        (e.time = 1e3 * t.time || Date.now()),
        t.blockhash && t.blockhash.length && (e.blockhash = t.blockhash),
        t.blocktime && (e.blocktime = t.blocktime),
        t.blockheight && (e.blockheight = t.blockheight),
        void 0 !== t.confirmations && (e.confirmations = t.confirmations),
        t.vout &&
          t.vout.forEach((t, r) => {
            void 0 !== t.spentTxId && (e.outputs[r].spentTxId = t.spentTxId),
              void 0 !== t.spentIndex &&
                (e.outputs[r].spentIndex = t.spentIndex),
              void 0 !== t.spentHeight &&
                (e.outputs[r].spentHeight = t.spentHeight);
          }),
        e
      );
    }
    const u = 'https://api.star.store',
      h = {
        broadcastUrl: t => `${u}/v1/${t}/tx`,
        broadcastData: t => ({ rawtx: t.toBuffer().toString('hex') }),
        fetchUrl: (t, e) => `${u}/v1/${t}/tx/${e}`,
        fetchResp: t => c(t),
        utxosUrl: (t, e) => `${u}/v1/${t}/utxos/${e.toString()}`,
        utxosResp: (t, e) => t
      },
      f = {
        broadcastUrl: t => `https://api.bitindex.network/api/v3/${t}/tx/send`,
        broadcastData: t => ({ rawtx: t.toBuffer().toString('hex') }),
        fetchUrl: (t, e) => `https://api.bitindex.network/api/v3/${t}/tx/${e}`,
        fetchResp: t => {
          const e = c(t);
          return (e.confirmations = e.confirmations || 0), e;
        },
        utxosUrl: (t, e) =>
          `https://api.bitindex.network/api/v3/${t}/addr/${e.toString()}/utxo`,
        utxosResp: (t, e) =>
          t.map(t => ({ ...t, script: new s(t.scriptPubKey) }))
      },
      l = {
        broadcastUrl: t => `https://api.whatsonchain.com/v1/bsv/${t}/tx/raw`,
        broadcastData: t => ({ txhex: t.toBuffer().toString('hex') }),
        fetchUrl: (t, e) =>
          `https://api.whatsonchain.com/v1/bsv/${t}/tx/hash/${e}`,
        fetchResp: t => {
          const e = c(t);
          return (e.confirmations = e.confirmations || 0), e;
        },
        utxosUrl: (t, e) =>
          `https://api.whatsonchain.com/v1/bsv/${t}/address/${e.toString()}/unspent`,
        utxosResp: (t, e) =>
          t.map(t => ({
            txid: t.tx_hash,
            vout: t.tx_pos,
            satoshis: t.value,
            script: s.fromAddress(e)
          }))
      };
    t.exports = {
      starApi: h,
      bitIndexApi: f,
      whatsOnChainApi: l,
      RestApi: class {
        constructor(t, e) {
          (this.network = t),
            (this.api = e),
            (this.bsvNetwork = 'main' === t ? 'mainnet' : 'testnet'),
            (this.axios = n.create({ timeout: 1e4 })),
            (this.txCache = new Map()),
            (this.txCacheMaxSize = 100),
            (this.txCacheExpiration = 15e5),
            (this.broadcastCache = []),
            (this.broadcastCacheTime = 6e5),
            (this.requests = new Map());
        }
        async broadcast(t) {
          if (0 === t.inputs.length) throw new Error('tx has no inputs');
          if (0 === t.outputs.length) throw new Error('tx has no outputs');
          if (t.getFee() < t.toBuffer().length)
            throw new Error('tx fee too low');
          if (!0 !== t.verify()) throw new Error(t.verify());
          if (!0 !== t.isFullySigned()) throw new Error('tx not fully signed');
          await a(
            this.axios.post(
              this.api.broadcastUrl(this.network),
              this.api.broadcastData(t)
            )
          );
          const e = Date.now();
          if (
            ((t.time = e),
            (t.lastFetchedTime = e),
            t.outputs.forEach(t => {
              (t.spentTxId = null),
                (t.spentIndex = null),
                (t.spentHeight = null);
            }),
            this.txCache.set(t.hash, t),
            this.txCache.size > this.txCacheMaxSize)
          ) {
            const t = this.txCache.keys().next().value;
            this.txCache.delete(t);
          }
          (this.broadcastCache = this.broadcastCache.filter(
            t => e - t.time < this.broadcastCacheTime
          )),
            this.broadcastCache.push(t);
        }
        async fetch(t, e = !1) {
          const r = e ? null : this.txCache.get(t);
          if (r && Date.now() - r.lastFetchedTime < this.txCacheExpiration)
            return this.txCache.delete(t), this.txCache.set(t, r), r;
          const n = this.requests.get(t);
          if (n)
            return new Promise((t, e) => {
              n.push({ resolve: t, reject: e });
            });
          this.requests.set(t, []);
          try {
            const e = (await a(
                this.axios.get(this.api.fetchUrl(this.network, t))
              )).data,
              r = this.api.fetchResp(e);
            if (
              ((r.lastFetchedTime = Date.now()),
              this.txCache.set(t, r),
              this.txCache.size > this.txCacheMaxSize)
            ) {
              const t = this.txCache.keys().next().value;
              this.txCache.delete(t);
            }
            return this.requests.get(t).forEach(t => t.resolve(r)), r;
          } catch (e) {
            throw (this.requests.get(t).forEach(t => t.reject(e)), e);
          } finally {
            this.requests.delete(t);
          }
        }
        async utxos(t) {
          t = new o(t).toString();
          const e = this.requests.get(t);
          if (e)
            return new Promise((t, r) => {
              e.push({ resolve: t, reject: r });
            });
          this.requests.set(t, []);
          try {
            const e = (await a(
                this.axios.get(this.api.utxosUrl(this.network, t))
              )).data,
              r = this.api.utxosResp(e, t),
              n = this._correctForServerUtxoIndexDelay(r, t);
            return this.requests.get(t).forEach(t => t.resolve(n)), n;
          } catch (e) {
            throw (this.requests.get(t).forEach(t => t.reject(e)), e);
          } finally {
            this.requests.delete(t);
          }
        }
        _correctForServerUtxoIndexDelay(t, e) {
          const r = Date.now();
          return (
            (this.broadcastCache = this.broadcastCache.filter(
              t => r - t.time < this.broadcastCacheTime
            )),
            this.broadcastCache.forEach(r => {
              r.outputs.forEach((n, o) => {
                n.script.toAddress(this.bsvNetwork).toString() !== e ||
                  t.some(t => t.txid === r.hash && t.vout === o) ||
                  t.push({
                    txid: r.hash,
                    vout: o,
                    script: n.script,
                    satoshis: n.satoshis
                  });
              });
            }),
            this.broadcastCache.forEach(e => {
              t = t.filter(
                t =>
                  !e.inputs.some(e =>
                    ((t, e) =>
                      t.prevTxId.toString('hex') === e.txid &&
                      t.outputIndex === e.vout)(e, t)
                  )
              );
            }),
            t
          );
        }
      }
    };
  },
  function(t, e, r) {
    t.exports = r(17);
  },
  function(t, e, r) {
    'use strict';
    var n = r(0),
      o = r(4),
      s = r(19),
      i = r(10);
    function a(t) {
      var e = new s(t),
        r = o(s.prototype.request, e);
      return n.extend(r, s.prototype, e), n.extend(r, e), r;
    }
    var c = a(r(7));
    (c.Axios = s),
      (c.create = function(t) {
        return a(i(c.defaults, t));
      }),
      (c.Cancel = r(11)),
      (c.CancelToken = r(32)),
      (c.isCancel = r(6)),
      (c.all = function(t) {
        return Promise.all(t);
      }),
      (c.spread = r(33)),
      (t.exports = c),
      (t.exports.default = c);
  },
  function(t, e) {
    t.exports = function(t) {
      return (
        null != t &&
        null != t.constructor &&
        'function' == typeof t.constructor.isBuffer &&
        t.constructor.isBuffer(t)
      );
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(0),
      o = r(5),
      s = r(20),
      i = r(21),
      a = r(10);
    function c(t) {
      (this.defaults = t),
        (this.interceptors = { request: new s(), response: new s() });
    }
    (c.prototype.request = function(t) {
      'string' == typeof t
        ? ((t = arguments[1] || {}).url = arguments[0])
        : (t = t || {}),
        ((t = a(this.defaults, t)).method = t.method
          ? t.method.toLowerCase()
          : 'get');
      var e = [i, void 0],
        r = Promise.resolve(t);
      for (
        this.interceptors.request.forEach(function(t) {
          e.unshift(t.fulfilled, t.rejected);
        }),
          this.interceptors.response.forEach(function(t) {
            e.push(t.fulfilled, t.rejected);
          });
        e.length;

      )
        r = r.then(e.shift(), e.shift());
      return r;
    }),
      (c.prototype.getUri = function(t) {
        return (
          (t = a(this.defaults, t)),
          o(t.url, t.params, t.paramsSerializer).replace(/^\?/, '')
        );
      }),
      n.forEach(['delete', 'get', 'head', 'options'], function(t) {
        c.prototype[t] = function(e, r) {
          return this.request(n.merge(r || {}, { method: t, url: e }));
        };
      }),
      n.forEach(['post', 'put', 'patch'], function(t) {
        c.prototype[t] = function(e, r, o) {
          return this.request(n.merge(o || {}, { method: t, url: e, data: r }));
        };
      }),
      (t.exports = c);
  },
  function(t, e, r) {
    'use strict';
    var n = r(0);
    function o() {
      this.handlers = [];
    }
    (o.prototype.use = function(t, e) {
      return (
        this.handlers.push({ fulfilled: t, rejected: e }),
        this.handlers.length - 1
      );
    }),
      (o.prototype.eject = function(t) {
        this.handlers[t] && (this.handlers[t] = null);
      }),
      (o.prototype.forEach = function(t) {
        n.forEach(this.handlers, function(e) {
          null !== e && t(e);
        });
      }),
      (t.exports = o);
  },
  function(t, e, r) {
    'use strict';
    var n = r(0),
      o = r(22),
      s = r(6),
      i = r(7),
      a = r(30),
      c = r(31);
    function u(t) {
      t.cancelToken && t.cancelToken.throwIfRequested();
    }
    t.exports = function(t) {
      return (
        u(t),
        t.baseURL && !a(t.url) && (t.url = c(t.baseURL, t.url)),
        (t.headers = t.headers || {}),
        (t.data = o(t.data, t.headers, t.transformRequest)),
        (t.headers = n.merge(
          t.headers.common || {},
          t.headers[t.method] || {},
          t.headers || {}
        )),
        n.forEach(
          ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
          function(e) {
            delete t.headers[e];
          }
        ),
        (t.adapter || i.adapter)(t).then(
          function(e) {
            return (
              u(t), (e.data = o(e.data, e.headers, t.transformResponse)), e
            );
          },
          function(e) {
            return (
              s(e) ||
                (u(t),
                e &&
                  e.response &&
                  (e.response.data = o(
                    e.response.data,
                    e.response.headers,
                    t.transformResponse
                  ))),
              Promise.reject(e)
            );
          }
        )
      );
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(0);
    t.exports = function(t, e, r) {
      return (
        n.forEach(r, function(r) {
          t = r(t, e);
        }),
        t
      );
    };
  },
  function(t, e) {
    var r,
      n,
      o = (t.exports = {});
    function s() {
      throw new Error('setTimeout has not been defined');
    }
    function i() {
      throw new Error('clearTimeout has not been defined');
    }
    function a(t) {
      if (r === setTimeout) return setTimeout(t, 0);
      if ((r === s || !r) && setTimeout)
        return (r = setTimeout), setTimeout(t, 0);
      try {
        return r(t, 0);
      } catch (e) {
        try {
          return r.call(null, t, 0);
        } catch (e) {
          return r.call(this, t, 0);
        }
      }
    }
    !(function() {
      try {
        r = 'function' == typeof setTimeout ? setTimeout : s;
      } catch (t) {
        r = s;
      }
      try {
        n = 'function' == typeof clearTimeout ? clearTimeout : i;
      } catch (t) {
        n = i;
      }
    })();
    var c,
      u = [],
      h = !1,
      f = -1;
    function l() {
      h &&
        c &&
        ((h = !1), c.length ? (u = c.concat(u)) : (f = -1), u.length && p());
    }
    function p() {
      if (!h) {
        var t = a(l);
        h = !0;
        for (var e = u.length; e; ) {
          for (c = u, u = []; ++f < e; ) c && c[f].run();
          (f = -1), (e = u.length);
        }
        (c = null),
          (h = !1),
          (function(t) {
            if (n === clearTimeout) return clearTimeout(t);
            if ((n === i || !n) && clearTimeout)
              return (n = clearTimeout), clearTimeout(t);
            try {
              n(t);
            } catch (e) {
              try {
                return n.call(null, t);
              } catch (e) {
                return n.call(this, t);
              }
            }
          })(t);
      }
    }
    function d(t, e) {
      (this.fun = t), (this.array = e);
    }
    function g() {}
    (o.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
      u.push(new d(t, e)), 1 !== u.length || h || a(p);
    }),
      (d.prototype.run = function() {
        this.fun.apply(null, this.array);
      }),
      (o.title = 'browser'),
      (o.browser = !0),
      (o.env = {}),
      (o.argv = []),
      (o.version = ''),
      (o.versions = {}),
      (o.on = g),
      (o.addListener = g),
      (o.once = g),
      (o.off = g),
      (o.removeListener = g),
      (o.removeAllListeners = g),
      (o.emit = g),
      (o.prependListener = g),
      (o.prependOnceListener = g),
      (o.listeners = function(t) {
        return [];
      }),
      (o.binding = function(t) {
        throw new Error('process.binding is not supported');
      }),
      (o.cwd = function() {
        return '/';
      }),
      (o.chdir = function(t) {
        throw new Error('process.chdir is not supported');
      }),
      (o.umask = function() {
        return 0;
      });
  },
  function(t, e, r) {
    'use strict';
    var n = r(0);
    t.exports = function(t, e) {
      n.forEach(t, function(r, n) {
        n !== e &&
          n.toUpperCase() === e.toUpperCase() &&
          ((t[e] = r), delete t[n]);
      });
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(9);
    t.exports = function(t, e, r) {
      var o = r.config.validateStatus;
      !o || o(r.status)
        ? t(r)
        : e(
            n(
              'Request failed with status code ' + r.status,
              r.config,
              null,
              r.request,
              r
            )
          );
    };
  },
  function(t, e, r) {
    'use strict';
    t.exports = function(t, e, r, n, o) {
      return (
        (t.config = e),
        r && (t.code = r),
        (t.request = n),
        (t.response = o),
        (t.isAxiosError = !0),
        (t.toJSON = function() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            ck: this.ck,
            config: this.config,
            code: this.code
          };
        }),
        t
      );
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(0),
      o = [
        'age',
        'authorization',
        'content-length',
        'content-type',
        'etag',
        'expires',
        'from',
        'host',
        'if-modified-since',
        'if-unmodified-since',
        'last-modified',
        'location',
        'max-forwards',
        'proxy-authorization',
        'referer',
        'retry-after',
        'user-agent'
      ];
    t.exports = function(t) {
      var e,
        r,
        s,
        i = {};
      return t
        ? (n.forEach(t.split('\n'), function(t) {
            if (
              ((s = t.indexOf(':')),
              (e = n.trim(t.substr(0, s)).toLowerCase()),
              (r = n.trim(t.substr(s + 1))),
              e)
            ) {
              if (i[e] && o.indexOf(e) >= 0) return;
              i[e] =
                'set-cookie' === e
                  ? (i[e] ? i[e] : []).concat([r])
                  : i[e]
                  ? i[e] + ', ' + r
                  : r;
            }
          }),
          i)
        : i;
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(0);
    t.exports = n.isStandardBrowserEnv()
      ? (function() {
          var t,
            e = /(msie|trident)/i.test(navigator.userAgent),
            r = document.createElement('a');
          function o(t) {
            var n = t;
            return (
              e && (r.setAttribute('href', n), (n = r.href)),
              r.setAttribute('href', n),
              {
                href: r.href,
                protocol: r.protocol ? r.protocol.replace(/:$/, '') : '',
                host: r.host,
                search: r.search ? r.search.replace(/^\?/, '') : '',
                hash: r.hash ? r.hash.replace(/^#/, '') : '',
                hostname: r.hostname,
                port: r.port,
                pathname:
                  '/' === r.pathname.charAt(0) ? r.pathname : '/' + r.pathname
              }
            );
          }
          return (
            (t = o(window.location.href)),
            function(e) {
              var r = n.isString(e) ? o(e) : e;
              return r.protocol === t.protocol && r.host === t.host;
            }
          );
        })()
      : function() {
          return !0;
        };
  },
  function(t, e, r) {
    'use strict';
    var n = r(0);
    t.exports = n.isStandardBrowserEnv()
      ? {
          write: function(t, e, r, o, s, i) {
            var a = [];
            a.push(t + '=' + encodeURIComponent(e)),
              n.isNumber(r) && a.push('expires=' + new Date(r).toGMTString()),
              n.isString(o) && a.push('path=' + o),
              n.isString(s) && a.push('domain=' + s),
              !0 === i && a.push('secure'),
              (document.cookie = a.join('; '));
          },
          read: function(t) {
            var e = document.cookie.match(
              new RegExp('(^|;\\s*)(' + t + ')=([^;]*)')
            );
            return e ? decodeURIComponent(e[3]) : null;
          },
          remove: function(t) {
            this.write(t, '', Date.now() - 864e5);
          }
        }
      : {
          write: function() {},
          read: function() {
            return null;
          },
          remove: function() {}
        };
  },
  function(t, e, r) {
    'use strict';
    t.exports = function(t) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t);
    };
  },
  function(t, e, r) {
    'use strict';
    t.exports = function(t, e) {
      return e ? t.replace(/\/+$/, '') + '/' + e.replace(/^\/+/, '') : t;
    };
  },
  function(t, e, r) {
    'use strict';
    var n = r(11);
    function o(t) {
      if ('function' != typeof t)
        throw new TypeError('executor must be a function.');
      var e;
      this.promise = new Promise(function(t) {
        e = t;
      });
      var r = this;
      t(function(t) {
        r.reason || ((r.reason = new n(t)), e(r.reason));
      });
    }
    (o.prototype.throwIfRequested = function() {
      if (this.reason) throw this.reason;
    }),
      (o.source = function() {
        var t;
        return {
          token: new o(function(e) {
            t = e;
          }),
          cancel: t
        };
      }),
      (t.exports = o);
  },
  function(t, e, r) {
    'use strict';
    t.exports = function(t) {
      return function(e) {
        return t.apply(null, e);
      };
    };
  },
  function(t, e, r) {
    const { Address: n, Transaction: o } = r(2);
    t.exports = class {
      constructor() {
        (this.sas = new Map()), (this.unspentOutputs = []);
      }
      async broadcast(t) {
        if (0 === t.inputs.length) throw new Error('tx has no inputs');
        if (0 === t.outputs.length) throw new Error('tx has no outputs');
        if (t.getFee() < t.toBuffer().length) throw new Error('tx fee too low');
        if (!0 !== t.verify()) throw new Error(t.verify());
        if (!0 !== t.isFullySigned()) throw new Error('tx not fully signed');
        let e = this.unspentOutputs.slice(0);
        const r = t => e =>
          e.txid === t.prevTxId.toString('hex') && e.vout === t.outputIndex;
        t.inputs.forEach((t, n) => {
          if (!e.some(r(t))) throw new Error(`tx input ${n} missing or spent`);
          e = e.filter(e => !r(t)(e));
        }),
          (this.unspentOutputs = this.unspentOutputs.filter(
            e => !t.inputs.some(t => r(t)(e))
          )),
          (t.time = t.time || Date.now()),
          (t.confirmations = 0),
          this.sas.set(t.hash, t),
          t.outputs.forEach(t => {
            (t.spentTxId = null), (t.spentIndex = null), (t.spentHeight = null);
          }),
          t.outputs.forEach((e, r) =>
            this.unspentOutputs.push({
              txid: t.hash,
              vout: r,
              script: e.script,
              satoshis: e.satoshis
            })
          ),
          t.inputs.forEach((e, r) => {
            const n = this.sas.get(e.prevTxId.toString('hex')).outputs[
              e.outputIndex
            ];
            (n.spentTxId = t.hash), (n.spentIndex = r), (n.spentHeight = -1);
          });
      }
      async fetch(t, e = !1) {
        const r = this.sas.get(t);
        if (r) return r;
        throw new Error(`tx not found: ${t}`);
      }
      async utxos(t) {
        const e = new n(t).toString();
        return this.unspentOutputs.filter(
          t => t.script.toAddress('testnet').toString() === e
        );
      }
      fund(t, e) {
        const r = Math.random().toString(),
          s = new o().addData(r).to(new n(t, 'testnet'), e);
        (s.time = Date.now()), (s.confirmations = 0), this.sas.set(s.hash, s);
        const i = s.outputs[1];
        this.unspentOutputs.push({
          txid: s.hash,
          vout: 1,
          script: i.script,
          satoshis: i.satoshis
        });
      }
    };
  },
  function(module, exports, __webpack_require__) {
    (function(global) {
      const vm =
          'undefined' == typeof window
            ? __webpack_require__(36)
            : __webpack_require__(37),
        Jig = __webpack_require__(38),
        util = __webpack_require__(12),
        bsv = __webpack_require__(2);
      function banNondeterministicGlobals(t) {
        [
          'Date',
          'Math',
          'eval',
          'XMLHttpRequest',
          'FileReader',
          'WebSocket',
          'setTimeout',
          'setInterval'
        ].forEach(e => {
          void 0 === t[e] && (t[e] = void 0);
        });
      }
      module.exports = class Code {
        constructor() {
          (this.ll = new Map()),
            'undefined' == typeof window ||
              window.document.body ||
              (window.document.body = document.createElement('body'));
          (this.ns = vm.runInContext(
            'Object.assign(...Object.entries(c).map(([k, f]) => ({ [k]: (...a) => f(...a) })))',
            vm.createContext({ c: console })
          )),
            this.ke();
        }
        nx(t) {
          const e = this.ll.get(t);
          return e && t === e;
        }
        al(t) {
          return this.nx(t) ? t : this.ll.get(t);
        }
        deploy(t) {
          if (t === this.Jig) return t;
          if (!util.dy(t)) {
                console.log('ah shit')  
            throw new Error(`not dy: ${t}`)};
          const e = this.ll.get(t),
            r = util.run(),
            n =
              'main' === r.network
                ? 'Mainnet'
                : 'test' === r.network
                ? 'Testnet'
                : 'stn' === r.network
                ? 'Stn'
                : 'Mocknet';
          if (
            e &&
            Object.keys(e).includes(`origin${n}`) &&
            Object.keys(e).includes(`location${n}`)
          )
            return e;
          const o = Object.keys(t);
          if (o.includes(`location${n}`)) {
            const e = this.ll.get(t[`location${n}`]);
            if (e) return e;
          }
          if (
            o.includes('deps') &&
            !(t => null === Object.getPrototypeOf(Object.getPrototypeOf(t)))(
              t.deps
            )
          )
            throw new Error('deps must be an object');
          const s = [
            'origin',
            'location',
            'originMainnet',
            'locationMainnet',
            'originTestnet',
            'locationTestnet',
            'originStn',
            'locationStn',
            'originMocknet',
            'locationMocknet',
            'owner',
            'ownerMainnet',
            'ownerTestnet',
            'ownerStn',
            'ownerMocknet'
          ];
          s.forEach(e => {
            if ((e => o.includes(e) && 'string' != typeof t[e])(e))
              throw new Error(`${e} must be a string: ${t[e]}`);
          }),
            r.sa.begin();
          try {
            const e = { console: this.ns },
              i = Object.getPrototypeOf(t),
              a = { ...t.deps };
            if (i !== Object.getPrototypeOf(Object)) {
              if (((e[i.name] = this.deploy(i)), a[i.name] && a[i.name] !== i))
                throw new Error(`unexpected parent dependency ${i.name}`);
              i.name in a || i === this.ll.get(Jig) || (a[i.name] = i);
            }
            const [c, u] = this.sandbox(t, util.code(t), t.name, e, r.sandbox);
            this.ll.set(t, c), this.ll.set(c, c);
            const h = {},
              f = ['deps', ...s],
              l = o.filter(t => !f.includes(t)),
              p = [],
              d = [util.jrp(this.Jig), util.crp(p)];
            if (
              (l.forEach(e => {
                util.ppp(t[e], d, `${t.name}.${e}`), (h[e] = t[e]);
              }),
              o.forEach(e => {
                c[e] = t[e];
              }),
              o.includes(`origin${n}`) || o.includes(`location${n}`))
            )
              o.includes(`origin${n}`) &&
                (c.origin = t.origin = t[`origin${n}`]),
                (c.location = t.location = t[`location${n}`] || t.origin),
                (c.owner = t.owner = t[`owner${n}`]);
            else {
              const e = r.network,
                o = o => {
                  r.network === e &&
                    ((t.origin = t.location = c.origin = c.location = o),
                    (t.owner = c.owner = t[`owner${n}`])),
                    (c[`origin${n}`] = c[`location${n}`] = o),
                    (t[`origin${n}`] = t[`location${n}`] = o),
                    this.ll.set(o, c);
                },
                s = () => {
                  r.network === e &&
                    (delete t.origin,
                    delete t.location,
                    delete c.origin,
                    delete c.location,
                    delete t.owner,
                    delete c.owner),
                    delete t[`origin${n}`],
                    delete t[`location${n}`],
                    delete c[`origin${n}`],
                    delete c[`location${n}`],
                    delete t[`owner${n}`],
                    delete c[`owner${n}`];
                },
                { tempLocation: i, owner: u } = r.sa.storeDefinition(
                  t,
                  a,
                  h,
                  o,
                  s
                );
              (t[`origin${n}`] = t[`location${n}`] = i),
                (c[`origin${n}`] = c[`location${n}`] = i),
                (t[`owner${n}`] = c[`owner${n}`] = u),
                (t.owner = c.owner = u);
            }
            return (
              u &&
                Object.entries(a).forEach(([t, r]) => {
                  if (r === i || r === e[i.name]) return;
                  Object.defineProperty(u, t, {
                    configurable: !0,
                    enumerable: !0,
                    value: this.deploy(r)
                  });
                }),
              p.forEach(t => this.deploy(t)),
              c
            );
          } finally {
            r.sa.end();
          }
        }
        async installFromTx(t, e, r, n, o) {
          if (this.ll.has(e)) return this.ll.get(e);
          const s = e.slice(0, 64),
            i = parseInt(e.slice(66));
          if (
            r.outputs[i].script.toAddress(o).toString() !==
            new bsv.PublicKey(t.owner, o).toAddress().toString()
          )
            throw new Error(`bad def owner: ${e}`);
          const a = { console: this.ns },
            c = /^class \w* extends (\w*)[\s]*{/;
          let u = null;
          if (c.test(t.code)) {
            u = t.code.match(c)[1];
            let e = (t.deps || {})[u];
            'Jig' === u && void 0 === e
              ? (a.Jig = this.Jig)
              : (e.startsWith('_') && (e = r.hash + e),
                (a[u] = await n.sa.load(e)));
          }
          const h = t.code.match(/^(class|function) (\w+)[( ]/)[2],
            [f, l] = this.sandbox(null, t.code, h, a, n.sandbox);
          (f.origin = f.location = e), (f.owner = t.owner);
          const p =
            'main' === n.network
              ? 'Mainnet'
              : 'test' === n.network
              ? 'Testnet'
              : 'stn' === n.network
              ? 'Stn'
              : 'Mocknet';
          if (
            ((f[`origin${p}`] = f[`location${p}`] = e),
            (f[`owner${p}`] = t.owner),
            this.ll.set(e, f),
            this.ll.set(f, f),
            l)
          ) {
            const e = Object.entries(t.deps || {}).map(([t, e]) => {
              if (t === u) return;
              const o = e.startsWith('_') ? r.hash + e : e;
              return n.sa.load(o).then(e => {
                Object.defineProperty(l, t, {
                  configurable: !0,
                  enumerable: !0,
                  value: e
                });
              });
            });
            await Promise.all(e);
          }
          const d = [];
          util.unppp(t.props || {}, [
            (t, e, r) => {
              if ('ref' === t.__class) return d.push(t.id), {};
            }
          ]);
          const g = await Promise.all(
              d.map(t =>
                n.sa.load((t => ('i' === t[1] || 'o' === t[1] ? s + t : t))(t))
              )
            ),
            w = util.unppp(t.props || {}, [
              (t, e, r) => {
                if ('ref' === t.__class) return g.shift();
              }
            ]);
          return (
            Object.keys(w).forEach(t => {
              f[t] = w[t];
            }),
            f
          );
        }
        ke() {
          this.ed = {
            ck: [],
            creates: new Set(),
            ea: new Set(),
            es: new Map(),
            callers: new Map(),
            error: !1,
            enforce: !0,
            oe: new Map(),
            locals: new WeakMap()
          };
          const t = { console: this.ns, ed: this.ed, code: this, util: util };
          (this.Jig = this.sandbox(Jig, Jig.toString(), 'Jig', t, !0)[0]),
            this.ll.set(Jig, this.Jig),
            this.ll.set(this.Jig, this.Jig);
        }
        sandbox(type, code, name, env, sandbox) {
          const prev = this.ll.get(type);
          if (prev) return [prev, null];
          (sandbox = sandbox instanceof RegExp ? sandbox.test(name) : sandbox),
            sandbox && (env.deps = {});
          const ed = this.ed;
          if (
            (Object.defineProperty(sandbox ? env.deps : global, 'caller', {
              configurable: !0,
              enumerable: !0,
              get: () =>
                ed.ck.length < 2 ? null : ed.oe.get(ed.ck[ed.ck.length - 2])
            }),
            !sandbox)
          )
            return (
              (type = type || eval(code)),
              Object.keys(env).forEach(t => {
                Object.defineProperty(global, t, {
                  value: env[t],
                  configurable: !0,
                  enumerable: !0,
                  writable: !0
                });
              }),
              [type, global]
            );
          banNondeterministicGlobals(env);
          const context = vm.createContext(env);
          'undefined' == typeof window && (context.global = context);
          const script = `with(deps){${code};${name}}`;
          return [vm.runInContext(script, context), env.deps];
        }
        activate(t) {
          const e =
            'main' === t
              ? 'Mainnet'
              : 'test' === t
              ? 'Testnet'
              : 'stn' === t
              ? 'Stn'
              : 'Mocknet';
          this.ll.forEach((t, r) => {
            'string' != typeof r &&
              (void 0 !== r[`origin${e}`]
                ? ((r.origin = r[`origin${e}`]), (t.origin = r[`origin${e}`]))
                : (delete r.origin, delete t.origin),
              void 0 !== r[`location${e}`]
                ? ((r.location = r[`location${e}`]),
                  (t.location = r[`location${e}`]))
                : (delete r.location, delete t.location),
              void 0 !== r[`owner${e}`]
                ? ((r.owner = r[`owner${e}`]), (t.owner = r[`owner${e}`]))
                : (delete r.owner, delete t.owner));
          });
        }
        flush() {
          (this.ll = new Map()),
            this.ll.set(Jig, this.Jig),
            this.ll.set(this.Jig, this.Jig);
        }
      };
    }.call(this, __webpack_require__(3)));
  },
  function(t, e) {
    t.exports = vm;
  },
  function(module, exports) {
    var indexOf = function(t, e) {
        if (t.indexOf) return t.indexOf(e);
        for (var r = 0; r < t.length; r++) if (t[r] === e) return r;
        return -1;
      },
      Object_keys = function(t) {
        if (Object.keys) return Object.keys(t);
        var e = [];
        for (var r in t) e.push(r);
        return e;
      },
      forEach = function(t, e) {
        if (t.forEach) return t.forEach(e);
        for (var r = 0; r < t.length; r++) e(t[r], r, t);
      },
      defineProp = (function() {
        try {
          return (
            Object.defineProperty({}, '_', {}),
            function(t, e, r) {
              Object.defineProperty(t, e, {
                writable: !0,
                enumerable: !1,
                configurable: !0,
                value: r
              });
            }
          );
        } catch (t) {
          return function(t, e, r) {
            t[e] = r;
          };
        }
      })(),
      globals = [
        'Array',
        'Boolean',
        'Date',
        'Error',
        'EvalError',
        'Function',
        'Infinity',
        'JSON',
        'Math',
        'NaN',
        'Number',
        'Object',
        'RangeError',
        'ReferenceError',
        'RegExp',
        'String',
        'SyntaxError',
        'TypeError',
        'URIError',
        'decodeURI',
        'decodeURIComponent',
        'encodeURI',
        'encodeURIComponent',
        'escape',
        'eval',
        'isFinite',
        'isNaN',
        'parseFloat',
        'parseInt',
        'undefined',
        'unescape'
      ];
    function Context() {}
    Context.prototype = {};
    var Script = (exports.Script = function(t) {
      if (!(this instanceof Script)) return new Script(t);
      this.code = t;
    });
    (Script.prototype.runInContext = function(t) {
      if (!(t instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var e = document.createElement('iframe');
      e.style || (e.style = {}),
        (e.style.display = 'none'),
        document.body.appendChild(e);
      var r = e.contentWindow,
        n = r.eval,
        o = r.execScript;
      !n && o && (o.call(r, 'null'), (n = r.eval)),
        forEach(Object_keys(t), function(e) {
          r[e] = t[e];
        }),
        forEach(globals, function(e) {
          t[e] && (r[e] = t[e]);
        });
      var s = Object_keys(r),
        i = n.call(r, this.code);
      return (
        forEach(Object_keys(r), function(e) {
          (e in t || -1 === indexOf(s, e)) && (t[e] = r[e]);
        }),
        forEach(globals, function(e) {
          e in t || defineProp(t, e, r[e]);
        }),
        document.body.removeChild(e),
        i
      );
    }),
      (Script.prototype.runInThisContext = function() {
        return eval(this.code);
      }),
      (Script.prototype.runInNewContext = function(t) {
        var e = Script.createContext(t),
          r = this.runInContext(e);
        return (
          t &&
            forEach(Object_keys(e), function(r) {
              t[r] = e[r];
            }),
          r
        );
      }),
      forEach(Object_keys(Script.prototype), function(t) {
        exports[t] = Script[t] = function(e) {
          var r = Script(e);
          return r[t].apply(r, [].slice.call(arguments, 1));
        };
      }),
      (exports.isContext = function(t) {
        return t instanceof Context;
      }),
      (exports.createScript = function(t) {
        return exports.Script(t);
      }),
      (exports.createContext = Script.createContext = function(t) {
        var e = new Context();
        return (
          'object' == typeof t &&
            forEach(Object_keys(t), function(r) {
              e[r] = t[r];
            }),
          e
        );
      });
  },
  function(t, e) {
    t.exports = class Jig {
      constructor(...t) {
        const e = util.run();
        if (!code.nx(this.constructor)) {
          e.sa.begin();
          try {
            return new (code.deploy(this.constructor))(...t);
          } finally {
            e.sa.end();
          }
        }
        const r = [];
        let n = this.constructor;
        for (; n !== Jig; ) r.push(n), (n = Object.getPrototypeOf(n));
        if (0 === r.length) throw new Error('Jig must be extended');
        if (r.some(t => t.toString().includes(' constructor(')))
          throw new Error('Jig must use init() instead of constructor()');
        const o = ['origin', 'location', 'owner', 'satoshis', 'sync', 'toJSON'];
        r.forEach(t => {
          o.forEach(t => {
            if (Object.prototype.hasOwnProperty.call(r[0].prototype, t))
              throw new Error(`must not override ${t}`);
          });
        });
        const s = [];
        [...r, Jig].forEach(t => {
          Object.getOwnPropertyNames(t.prototype).forEach(t => s.push(t));
        });
        const i = [...s, 'owner', 'satoshis', 'origin', 'location'];
        function a() {
          (ed.creates = new Set()),
            (ed.ea = new Set()),
            (ed.es = new Map()),
            (ed.callers = new Map()),
            (ed.oe = new Map()),
            (ed.enforce = !0),
            (ed.error = !1);
        }
        const c = () => {
            if (this.origin && '!' === this.origin[0])
              throw new Error(`${this.origin.slice(1)}`);
          },
          u = { el: !0, nt: !1 },
          h = this,
          f = new Proxy(this, u);
        return (
          Object.assign(u, {
            getPrototypeOf: t => (
              c(), ed.oe.set(t, f), Object.getPrototypeOf(t)
            ),
            setPrototypeOf(t, e) {
              throw new Error('setPrototypeOf disallowed');
            },
            isExtensible: t => !0,
            preventExtensions(t) {
              throw new Error('preventExtensions disallowed');
            },
            getOwnPropertyDescriptor(t, e) {
              if ((c(), ed.oe.set(t, f), !this.has(t, e))) return;
              const r = Object.getOwnPropertyDescriptor(t, e);
              if (!r) return;
              const n = this.get(t, e);
              return { ...r, value: n };
            },
            defineProperty(t, e, r) {
              throw new Error('defineProperty disallowed');
            },
            has(t, e) {
              if (
                (c(),
                ed.oe.set(t, f),
                '_' === e[0] &&
                  ed.ck.length &&
                  ed.ck[ed.ck.length - 1].constructor !== f.constructor)
              )
                throw new Error(`cannot check ${e} because it is private`);
              return (
                ed.ck.length && (!this.el || !i.includes(e)) && ed.ea.add(h),
                void 0 !== t[e]
              );
            },
            get(t, e, r) {
              c(), ed.oe.set(t, f);
              if (
                this.el &&
                ed.enforce &&
                ['location'].includes(e) &&
                ed.ck.length
              )
                throw new Error(`${e} may only be read externally`);
              if (
                this.el &&
                ed.enforce &&
                ['origin', 'location'].includes(e) &&
                '_' === t[e][0]
              )
                throw new Error(`sync required before reading ${e}`);
              if (this.el && ['origin', 'constructor', 'toJSON'].includes(e))
                return t[e];
              const n = this.el && 'function' == typeof t[e];
              if (
                (ed.ck.length && !n && ed.ea.add(h),
                '_' === e[0] &&
                  ed.ck.length &&
                  ed.ck[ed.ck.length - 1].constructor !== f.constructor)
              )
                throw new Error(`cannot get ${e} because it is private`);
              return [
                'undefined',
                'boolean',
                'number',
                'string',
                'symbol'
              ].includes(typeof t[e])
                ? t[e]
                : e === Symbol.iterator
                ? t[e]
                : 'object' == typeof t[e]
                ? null === t[e]
                  ? null
                  : t[e] instanceof Jig
                  ? t[e]
                  : new Proxy(t[e], { ...this, el: !1 })
                : 'function' == typeof t[e]
                ? util.dy(t[e]) && !s.includes(e)
                  ? t[e]
                  : (...r) => {
                      if (!this.el) {
                        const n = [
                            'concat',
                            'entries',
                            'every',
                            'filter',
                            'find',
                            'findIndex',
                            'forEach',
                            'includes',
                            'indexOf',
                            'join',
                            'keys',
                            'lastIndexOf',
                            'map',
                            'reduce',
                            'reduceRight',
                            'slice',
                            'some',
                            'toLocaleString',
                            'toString'
                          ],
                          o = (t, e) => Array.isArray(t) && n.includes(e);
                        if (
                          !(
                            (ed.ck.length && ed.ck[ed.ck.length - 1] === h) ||
                            o(t, e)
                          )
                        )
                          throw new Error(
                            `internal method ${e} cannot be called externally`
                          );
                        return t[e](...r);
                      }
                      if (
                        '_' === e[0] &&
                        (!ed.ck.length ||
                          ed.ck[ed.ck.length - 1].constructor !== f.constructor)
                      )
                        throw new Error(
                          `cannot call ${e} because it is private`
                        );
                      if ('sync' === e) {
                        if (ed.ck.length)
                          throw new Error('sync may only be called externally');
                        return t[e].call(f, ...r);
                      }
                      const n = util.run();
                      n.sa.begin();
                      const o = ed.callers.get(h) || new Set();
                      ed.ck.forEach(t => o.add(t)),
                        ed.callers.set(h, o),
                        ed.ck.push(h);
                      try {
                        if ('init' === e && this.nt)
                          throw new Error('init cannot be called twice');
                        'init' === e && ((this.nt = !0), ed.creates.add(t));
                        const o = new Set(ed.ea);
                        ed.enforce = !1;
                        const s = [],
                          i = util.ppp(r, [
                            util.jrp(Jig, s),
                            util.crp(s, t => code.deploy(t))
                          ]);
                        if (!ed.es.has(t)) {
                          const e = { refs: [] },
                            r = util.jrp(Jig, e.refs, !0),
                            n = util.crp(e.refs, t => code.deploy(t));
                          (e.value = util.ppp(t, [r, n])), ed.es.set(t, e);
                        }
                        (ed.enforce = !0), (ed.ea = o);
                        const c = util.unppp(i, [util.rfu(s)]),
                          u = t[e].call(f, ...c);
                        if ('init' === e && void 0 !== u)
                          throw new Error('init must not return');
                        if ((n.sa.kw(t.owner), n.sa.ks(t.satoshis), ed.error))
                          throw new Error('internal error');
                        if (1 === ed.ck.length) {
                          const o = new Set(ed.ea);
                          ed.enforce = !1;
                          const s = new Map();
                          ed.ea.forEach(t => {
                            const e = [],
                              r = [util.jrp(Jig, e, !0), util.crp(e)];
                            s.set(t, { value: util.ppp(t, r), refs: e });
                          }),
                            Array.from(ed.es.keys()).forEach(t => {
                              const e = [],
                                r = [util.jrp(Jig, e, !0), util.crp(e)];
                              s.set(t, { value: util.ppp(t, r), refs: e });
                            });
                          const i = [];
                          for (const [t, e] of ed.es) {
                            const r = s.get(t),
                              n = (t, e) => t !== r.refs[e];
                            (util.dsa(e.value, r.value) || e.refs.some(n)) &&
                              i.push(t);
                          }
                          if (
                            ((ed.enforce = !0),
                            (ed.ea = o),
                            ed.creates.size || i.length)
                          ) {
                            const o = new Set(),
                              a = new Set(),
                              c = new Set(ed.ea),
                              u = t => {
                                a.add(t), ed.creates.has(t) || o.add(t);
                              };
                            i.forEach(t => {
                              ed.callers.get(t).forEach(t => u(t)), u(t);
                            }),
                              ed.creates.forEach(t => {
                                ed.callers.get(t).forEach(t => u(t)), u(t);
                              }),
                              n.sa.storeAction(
                                t,
                                e,
                                r,
                                o,
                                a,
                                c,
                                ed.es,
                                s,
                                ed.oe
                              );
                          }
                          a();
                        }
                        return u;
                      } catch (t) {
                        throw ((ed.error = !0),
                        1 === ed.ck.length &&
                          (ed.es.forEach((t, e) => {
                            Object.keys(e).forEach(t => delete e[t]),
                              Object.assign(
                                e,
                                util.unppp(t.value, [util.rfu(t.refs)])
                              );
                          }),
                          a()),
                        t);
                      } finally {
                        ed.ck.pop(), n.sa.end();
                      }
                    }
                : void 0;
            },
            set(t, e, r, n) {
              c(), ed.oe.set(t, f);
              const o = ['origin', 'location', 'toJSON', ...s];
              if (ed.enforce && this.el && o.includes(e))
                throw new Error(`must not set ${e}`);
              if (!util.dy(t[e]) && 'function' == typeof t[e])
                throw new Error(`must not set method ${e}`);
              if (
                ed.enforce &&
                (!ed.ck.length || ed.ck[ed.ck.length - 1] !== h)
              )
                throw new Error('properties cannot be set outside of methods');
              return (t[e] = r), !0;
            },
            deleteProperty(t, e) {
              c(), ed.oe.set(t, f);
              const r = ['origin', 'location', ...s];
              if (this.el && r.includes(e))
                throw new Error(`must not delete ${e}`);
              if (!util.dy(t[e]) && 'function' == typeof t[e])
                throw new Error(`must not set method ${e}`);
              if (
                ed.enforce &&
                (!ed.ck.length || ed.ck[ed.ck.length - 1] !== h)
              )
                throw new Error(
                  'properties cannot be deleted outside of methods'
                );
              return delete t[e], !0;
            },
            ownKeys: t => (
              c(),
              ed.oe.set(t, f),
              ed.ck.length && ed.ea.add(h),
              ed.ck.length &&
              ed.ck[ed.ck.length - 1].constructor !== f.constructor
                ? Reflect.ownKeys(t).filter(t => '_' !== t[0])
                : Reflect.ownKeys(t)
            )
          }),
          (this.owner = ed.ck.length
            ? ed.ck[ed.ck.length - 1].owner
            : e.sa.owner),
          (this.satoshis = 0),
          f.init(...t),
          f
        );
      }
      init() {}
      toString() {
        return `[jig ${this.constructor.name}]`;
      }
      sync(t) {
        return util.run().sa.sync({ ...t, target: this });
      }
      static [Symbol.hasInstance](t) {
        const e = code.al(this);
        if (!e) return !1;
        let r = Object.getPrototypeOf(t);
        for (; r; ) {
          if (r === e.prototype) return !0;
          r = Object.getPrototypeOf(r);
        }
        return !1;
      }
    };
  },
  function(t, e, r) {
    'use strict';
    (function(t) {
      var n = r(40),
        o = r(41),
        s = r(42);
      function i() {
        return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function a(t, e) {
        if (i() < e) throw new RangeError('Invalid typed array length');
        return (
          c.TYPED_ARRAY_SUPPORT
            ? ((t = new Uint8Array(e)).__proto__ = c.prototype)
            : (null === t && (t = new c(e)), (t.length = e)),
          t
        );
      }
      function c(t, e, r) {
        if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c))
          return new c(t, e, r);
        if ('number' == typeof t) {
          if ('string' == typeof e)
            throw new Error(
              'If encoding is specified then the first argument must be a string'
            );
          return f(this, t);
        }
        return u(this, t, e, r);
      }
      function u(t, e, r, n) {
        if ('number' == typeof e)
          throw new TypeError('"value" argument must not be a number');
        return 'undefined' != typeof ArrayBuffer && e instanceof ArrayBuffer
          ? (function(t, e, r, n) {
              if ((e.byteLength, r < 0 || e.byteLength < r))
                throw new RangeError("'offset' is out of bounds");
              if (e.byteLength < r + (n || 0))
                throw new RangeError("'length' is out of bounds");
              e =
                void 0 === r && void 0 === n
                  ? new Uint8Array(e)
                  : void 0 === n
                  ? new Uint8Array(e, r)
                  : new Uint8Array(e, r, n);
              c.TYPED_ARRAY_SUPPORT
                ? ((t = e).__proto__ = c.prototype)
                : (t = l(t, e));
              return t;
            })(t, e, r, n)
          : 'string' == typeof e
          ? (function(t, e, r) {
              ('string' == typeof r && '' !== r) || (r = 'utf8');
              if (!c.isEncoding(r))
                throw new TypeError(
                  '"encoding" must be a valid string encoding'
                );
              var n = 0 | d(e, r),
                o = (t = a(t, n)).write(e, r);
              o !== n && (t = t.slice(0, o));
              return t;
            })(t, e, r)
          : (function(t, e) {
              if (c.isBuffer(e)) {
                var r = 0 | p(e.length);
                return 0 === (t = a(t, r)).length ? t : (e.copy(t, 0, 0, r), t);
              }
              if (e) {
                if (
                  ('undefined' != typeof ArrayBuffer &&
                    e.buffer instanceof ArrayBuffer) ||
                  'length' in e
                )
                  return 'number' != typeof e.length || (n = e.length) != n
                    ? a(t, 0)
                    : l(t, e);
                if ('Buffer' === e.type && s(e.data)) return l(t, e.data);
              }
              var n;
              throw new TypeError(
                'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
              );
            })(t, e);
      }
      function h(t) {
        if ('number' != typeof t)
          throw new TypeError('"size" argument must be a number');
        if (t < 0) throw new RangeError('"size" argument must not be negative');
      }
      function f(t, e) {
        if ((h(e), (t = a(t, e < 0 ? 0 : 0 | p(e))), !c.TYPED_ARRAY_SUPPORT))
          for (var r = 0; r < e; ++r) t[r] = 0;
        return t;
      }
      function l(t, e) {
        var r = e.length < 0 ? 0 : 0 | p(e.length);
        t = a(t, r);
        for (var n = 0; n < r; n += 1) t[n] = 255 & e[n];
        return t;
      }
      function p(t) {
        if (t >= i())
          throw new RangeError(
            'Attempt to allocate Buffer larger than maximum size: 0x' +
              i().toString(16) +
              ' bytes'
          );
        return 0 | t;
      }
      function d(t, e) {
        if (c.isBuffer(t)) return t.length;
        if (
          'undefined' != typeof ArrayBuffer &&
          'function' == typeof ArrayBuffer.isView &&
          (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
        )
          return t.byteLength;
        'string' != typeof t && (t = '' + t);
        var r = t.length;
        if (0 === r) return 0;
        for (var n = !1; ; )
          switch (e) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return r;
            case 'utf8':
            case 'utf-8':
            case void 0:
              return q(t).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 2 * r;
            case 'hex':
              return r >>> 1;
            case 'base64':
              return Y(t).length;
            default:
              if (n) return q(t).length;
              (e = ('' + e).toLowerCase()), (n = !0);
          }
      }
      function g(t, e, r) {
        var n = !1;
        if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return '';
        if (((void 0 === r || r > this.length) && (r = this.length), r <= 0))
          return '';
        if ((r >>>= 0) <= (e >>>= 0)) return '';
        for (t || (t = 'utf8'); ; )
          switch (t) {
            case 'hex':
              return $(this, e, r);
            case 'utf8':
            case 'utf-8':
              return T(this, e, r);
            case 'ascii':
              return O(this, e, r);
            case 'latin1':
            case 'binary':
              return P(this, e, r);
            case 'base64':
              return S(this, e, r);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return R(this, e, r);
            default:
              if (n) throw new TypeError('Unknown encoding: ' + t);
              (t = (t + '').toLowerCase()), (n = !0);
          }
      }
      function w(t, e, r) {
        var n = t[e];
        (t[e] = t[r]), (t[r] = n);
      }
      function y(t, e, r, n, o) {
        if (0 === t.length) return -1;
        if (
          ('string' == typeof r
            ? ((n = r), (r = 0))
            : r > 2147483647
            ? (r = 2147483647)
            : r < -2147483648 && (r = -2147483648),
          (r = +r),
          isNaN(r) && (r = o ? 0 : t.length - 1),
          r < 0 && (r = t.length + r),
          r >= t.length)
        ) {
          if (o) return -1;
          r = t.length - 1;
        } else if (r < 0) {
          if (!o) return -1;
          r = 0;
        }
        if (('string' == typeof e && (e = c.from(e, n)), c.isBuffer(e)))
          return 0 === e.length ? -1 : b(t, e, r, n, o);
        if ('number' == typeof e)
          return (
            (e &= 255),
            c.TYPED_ARRAY_SUPPORT &&
            'function' == typeof Uint8Array.prototype.indexOf
              ? o
                ? Uint8Array.prototype.indexOf.call(t, e, r)
                : Uint8Array.prototype.lastIndexOf.call(t, e, r)
              : b(t, [e], r, n, o)
          );
        throw new TypeError('val must be string, number or Buffer');
      }
      function b(t, e, r, n, o) {
        var s,
          i = 1,
          a = t.length,
          c = e.length;
        if (
          void 0 !== n &&
          ('ucs2' === (n = String(n).toLowerCase()) ||
            'ucs-2' === n ||
            'utf16le' === n ||
            'utf-16le' === n)
        ) {
          if (t.length < 2 || e.length < 2) return -1;
          (i = 2), (a /= 2), (c /= 2), (r /= 2);
        }
        function u(t, e) {
          return 1 === i ? t[e] : t.readUInt16BE(e * i);
        }
        if (o) {
          var h = -1;
          for (s = r; s < a; s++)
            if (u(t, s) === u(e, -1 === h ? 0 : s - h)) {
              if ((-1 === h && (h = s), s - h + 1 === c)) return h * i;
            } else -1 !== h && (s -= s - h), (h = -1);
        } else
          for (r + c > a && (r = a - c), s = r; s >= 0; s--) {
            for (var f = !0, l = 0; l < c; l++)
              if (u(t, s + l) !== u(e, l)) {
                f = !1;
                break;
              }
            if (f) return s;
          }
        return -1;
      }
      function m(t, e, r, n) {
        r = Number(r) || 0;
        var o = t.length - r;
        n ? (n = Number(n)) > o && (n = o) : (n = o);
        var s = e.length;
        if (s % 2 != 0) throw new TypeError('Invalid hex string');
        n > s / 2 && (n = s / 2);
        for (var i = 0; i < n; ++i) {
          var a = parseInt(e.substr(2 * i, 2), 16);
          if (isNaN(a)) return i;
          t[r + i] = a;
        }
        return i;
      }
      function v(t, e, r, n) {
        return J(q(e, t.length - r), t, r, n);
      }
      function x(t, e, r, n) {
        return J(
          (function(t) {
            for (var e = [], r = 0; r < t.length; ++r)
              e.push(255 & t.charCodeAt(r));
            return e;
          })(e),
          t,
          r,
          n
        );
      }
      function E(t, e, r, n) {
        return x(t, e, r, n);
      }
      function k(t, e, r, n) {
        return J(Y(e), t, r, n);
      }
      function _(t, e, r, n) {
        return J(
          (function(t, e) {
            for (
              var r, n, o, s = [], i = 0;
              i < t.length && !((e -= 2) < 0);
              ++i
            )
              (r = t.charCodeAt(i)),
                (n = r >> 8),
                (o = r % 256),
                s.push(o),
                s.push(n);
            return s;
          })(e, t.length - r),
          t,
          r,
          n
        );
      }
      function S(t, e, r) {
        return 0 === e && r === t.length
          ? n.fromByteArray(t)
          : n.fromByteArray(t.slice(e, r));
      }
      function T(t, e, r) {
        r = Math.min(t.length, r);
        for (var n = [], o = e; o < r; ) {
          var s,
            i,
            a,
            c,
            u = t[o],
            h = null,
            f = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
          if (o + f <= r)
            switch (f) {
              case 1:
                u < 128 && (h = u);
                break;
              case 2:
                128 == (192 & (s = t[o + 1])) &&
                  (c = ((31 & u) << 6) | (63 & s)) > 127 &&
                  (h = c);
                break;
              case 3:
                (s = t[o + 1]),
                  (i = t[o + 2]),
                  128 == (192 & s) &&
                    128 == (192 & i) &&
                    (c = ((15 & u) << 12) | ((63 & s) << 6) | (63 & i)) >
                      2047 &&
                    (c < 55296 || c > 57343) &&
                    (h = c);
                break;
              case 4:
                (s = t[o + 1]),
                  (i = t[o + 2]),
                  (a = t[o + 3]),
                  128 == (192 & s) &&
                    128 == (192 & i) &&
                    128 == (192 & a) &&
                    (c =
                      ((15 & u) << 18) |
                      ((63 & s) << 12) |
                      ((63 & i) << 6) |
                      (63 & a)) > 65535 &&
                    c < 1114112 &&
                    (h = c);
            }
          null === h
            ? ((h = 65533), (f = 1))
            : h > 65535 &&
              ((h -= 65536),
              n.push(((h >>> 10) & 1023) | 55296),
              (h = 56320 | (1023 & h))),
            n.push(h),
            (o += f);
        }
        return (function(t) {
          var e = t.length;
          if (e <= A) return String.fromCharCode.apply(String, t);
          var r = '',
            n = 0;
          for (; n < e; )
            r += String.fromCharCode.apply(String, t.slice(n, (n += A)));
          return r;
        })(n);
      }
      (e.Buffer = c),
        (e.SlowBuffer = function(t) {
          +t != t && (t = 0);
          return c.alloc(+t);
        }),
        (e.INSPECT_MAX_BYTES = 50),
        (c.TYPED_ARRAY_SUPPORT =
          void 0 !== t.TYPED_ARRAY_SUPPORT
            ? t.TYPED_ARRAY_SUPPORT
            : (function() {
                try {
                  var t = new Uint8Array(1);
                  return (
                    (t.__proto__ = {
                      __proto__: Uint8Array.prototype,
                      foo: function() {
                        return 42;
                      }
                    }),
                    42 === t.foo() &&
                      'function' == typeof t.subarray &&
                      0 === t.subarray(1, 1).byteLength
                  );
                } catch (t) {
                  return !1;
                }
              })()),
        (e.kMaxLength = i()),
        (c.poolSize = 8192),
        (c._augment = function(t) {
          return (t.__proto__ = c.prototype), t;
        }),
        (c.from = function(t, e, r) {
          return u(null, t, e, r);
        }),
        c.TYPED_ARRAY_SUPPORT &&
          ((c.prototype.__proto__ = Uint8Array.prototype),
          (c.__proto__ = Uint8Array),
          'undefined' != typeof Symbol &&
            Symbol.species &&
            c[Symbol.species] === c &&
            Object.defineProperty(c, Symbol.species, {
              value: null,
              configurable: !0
            })),
        (c.alloc = function(t, e, r) {
          return (function(t, e, r, n) {
            return (
              h(e),
              e <= 0
                ? a(t, e)
                : void 0 !== r
                ? 'string' == typeof n
                  ? a(t, e).fill(r, n)
                  : a(t, e).fill(r)
                : a(t, e)
            );
          })(null, t, e, r);
        }),
        (c.allocUnsafe = function(t) {
          return f(null, t);
        }),
        (c.allocUnsafeSlow = function(t) {
          return f(null, t);
        }),
        (c.isBuffer = function(t) {
          return !(null == t || !t._isBuffer);
        }),
        (c.compare = function(t, e) {
          if (!c.isBuffer(t) || !c.isBuffer(e))
            throw new TypeError('Arguments must be Buffers');
          if (t === e) return 0;
          for (
            var r = t.length, n = e.length, o = 0, s = Math.min(r, n);
            o < s;
            ++o
          )
            if (t[o] !== e[o]) {
              (r = t[o]), (n = e[o]);
              break;
            }
          return r < n ? -1 : n < r ? 1 : 0;
        }),
        (c.isEncoding = function(t) {
          switch (String(t).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return !0;
            default:
              return !1;
          }
        }),
        (c.concat = function(t, e) {
          if (!s(t))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === t.length) return c.alloc(0);
          var r;
          if (void 0 === e)
            for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;
          var n = c.allocUnsafe(e),
            o = 0;
          for (r = 0; r < t.length; ++r) {
            var i = t[r];
            if (!c.isBuffer(i))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            i.copy(n, o), (o += i.length);
          }
          return n;
        }),
        (c.byteLength = d),
        (c.prototype._isBuffer = !0),
        (c.prototype.swap16 = function() {
          var t = this.length;
          if (t % 2 != 0)
            throw new RangeError('Buffer size must be a multiple of 16-bits');
          for (var e = 0; e < t; e += 2) w(this, e, e + 1);
          return this;
        }),
        (c.prototype.swap32 = function() {
          var t = this.length;
          if (t % 4 != 0)
            throw new RangeError('Buffer size must be a multiple of 32-bits');
          for (var e = 0; e < t; e += 4)
            w(this, e, e + 3), w(this, e + 1, e + 2);
          return this;
        }),
        (c.prototype.swap64 = function() {
          var t = this.length;
          if (t % 8 != 0)
            throw new RangeError('Buffer size must be a multiple of 64-bits');
          for (var e = 0; e < t; e += 8)
            w(this, e, e + 7),
              w(this, e + 1, e + 6),
              w(this, e + 2, e + 5),
              w(this, e + 3, e + 4);
          return this;
        }),
        (c.prototype.toString = function() {
          var t = 0 | this.length;
          return 0 === t
            ? ''
            : 0 === arguments.length
            ? T(this, 0, t)
            : g.apply(this, arguments);
        }),
        (c.prototype.equals = function(t) {
          if (!c.isBuffer(t)) throw new TypeError('Argument must be a Buffer');
          return this === t || 0 === c.compare(this, t);
        }),
        (c.prototype.inspect = function() {
          var t = '',
            r = e.INSPECT_MAX_BYTES;
          return (
            this.length > 0 &&
              ((t = this.toString('hex', 0, r)
                .match(/.{2}/g)
                .join(' ')),
              this.length > r && (t += ' ... ')),
            '<Buffer ' + t + '>'
          );
        }),
        (c.prototype.compare = function(t, e, r, n, o) {
          if (!c.isBuffer(t)) throw new TypeError('Argument must be a Buffer');
          if (
            (void 0 === e && (e = 0),
            void 0 === r && (r = t ? t.length : 0),
            void 0 === n && (n = 0),
            void 0 === o && (o = this.length),
            e < 0 || r > t.length || n < 0 || o > this.length)
          )
            throw new RangeError('out of range index');
          if (n >= o && e >= r) return 0;
          if (n >= o) return -1;
          if (e >= r) return 1;
          if (this === t) return 0;
          for (
            var s = (o >>>= 0) - (n >>>= 0),
              i = (r >>>= 0) - (e >>>= 0),
              a = Math.min(s, i),
              u = this.slice(n, o),
              h = t.slice(e, r),
              f = 0;
            f < a;
            ++f
          )
            if (u[f] !== h[f]) {
              (s = u[f]), (i = h[f]);
              break;
            }
          return s < i ? -1 : i < s ? 1 : 0;
        }),
        (c.prototype.includes = function(t, e, r) {
          return -1 !== this.indexOf(t, e, r);
        }),
        (c.prototype.indexOf = function(t, e, r) {
          return y(this, t, e, r, !0);
        }),
        (c.prototype.lastIndexOf = function(t, e, r) {
          return y(this, t, e, r, !1);
        }),
        (c.prototype.write = function(t, e, r, n) {
          if (void 0 === e) (n = 'utf8'), (r = this.length), (e = 0);
          else if (void 0 === r && 'string' == typeof e)
            (n = e), (r = this.length), (e = 0);
          else {
            if (!isFinite(e))
              throw new Error(
                'Buffer.write(string, encoding, offset[, length]) is no longer supported'
              );
            (e |= 0),
              isFinite(r)
                ? ((r |= 0), void 0 === n && (n = 'utf8'))
                : ((n = r), (r = void 0));
          }
          var o = this.length - e;
          if (
            ((void 0 === r || r > o) && (r = o),
            (t.length > 0 && (r < 0 || e < 0)) || e > this.length)
          )
            throw new RangeError('Attempt to write outside buffer bounds');
          n || (n = 'utf8');
          for (var s = !1; ; )
            switch (n) {
              case 'hex':
                return m(this, t, e, r);
              case 'utf8':
              case 'utf-8':
                return v(this, t, e, r);
              case 'ascii':
                return x(this, t, e, r);
              case 'latin1':
              case 'binary':
                return E(this, t, e, r);
              case 'base64':
                return k(this, t, e, r);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return _(this, t, e, r);
              default:
                if (s) throw new TypeError('Unknown encoding: ' + n);
                (n = ('' + n).toLowerCase()), (s = !0);
            }
        }),
        (c.prototype.toJSON = function() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        });
      var A = 4096;
      function O(t, e, r) {
        var n = '';
        r = Math.min(t.length, r);
        for (var o = e; o < r; ++o) n += String.fromCharCode(127 & t[o]);
        return n;
      }
      function P(t, e, r) {
        var n = '';
        r = Math.min(t.length, r);
        for (var o = e; o < r; ++o) n += String.fromCharCode(t[o]);
        return n;
      }
      function $(t, e, r) {
        var n = t.length;
        (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);
        for (var o = '', s = e; s < r; ++s) o += D(t[s]);
        return o;
      }
      function R(t, e, r) {
        for (var n = t.slice(e, r), o = '', s = 0; s < n.length; s += 2)
          o += String.fromCharCode(n[s] + 256 * n[s + 1]);
        return o;
      }
      function j(t, e, r) {
        if (t % 1 != 0 || t < 0) throw new RangeError('offset is not uint');
        if (t + e > r)
          throw new RangeError('Trying to access beyond buffer length');
      }
      function I(t, e, r, n, o, s) {
        if (!c.isBuffer(t))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > o || e < s)
          throw new RangeError('"value" argument is out of bounds');
        if (r + n > t.length) throw new RangeError('Index out of range');
      }
      function C(t, e, r, n) {
        e < 0 && (e = 65535 + e + 1);
        for (var o = 0, s = Math.min(t.length - r, 2); o < s; ++o)
          t[r + o] =
            (e & (255 << (8 * (n ? o : 1 - o)))) >>> (8 * (n ? o : 1 - o));
      }
      function B(t, e, r, n) {
        e < 0 && (e = 4294967295 + e + 1);
        for (var o = 0, s = Math.min(t.length - r, 4); o < s; ++o)
          t[r + o] = (e >>> (8 * (n ? o : 3 - o))) & 255;
      }
      function U(t, e, r, n, o, s) {
        if (r + n > t.length) throw new RangeError('Index out of range');
        if (r < 0) throw new RangeError('Index out of range');
      }
      function N(t, e, r, n, s) {
        return s || U(t, 0, r, 4), o.write(t, e, r, n, 23, 4), r + 4;
      }
      function M(t, e, r, n, s) {
        return s || U(t, 0, r, 8), o.write(t, e, r, n, 52, 8), r + 8;
      }
      (c.prototype.slice = function(t, e) {
        var r,
          n = this.length;
        if (
          ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
          (e = void 0 === e ? n : ~~e) < 0
            ? (e += n) < 0 && (e = 0)
            : e > n && (e = n),
          e < t && (e = t),
          c.TYPED_ARRAY_SUPPORT)
        )
          (r = this.subarray(t, e)).__proto__ = c.prototype;
        else {
          var o = e - t;
          r = new c(o, void 0);
          for (var s = 0; s < o; ++s) r[s] = this[s + t];
        }
        return r;
      }),
        (c.prototype.readUIntLE = function(t, e, r) {
          (t |= 0), (e |= 0), r || j(t, e, this.length);
          for (var n = this[t], o = 1, s = 0; ++s < e && (o *= 256); )
            n += this[t + s] * o;
          return n;
        }),
        (c.prototype.readUIntBE = function(t, e, r) {
          (t |= 0), (e |= 0), r || j(t, e, this.length);
          for (var n = this[t + --e], o = 1; e > 0 && (o *= 256); )
            n += this[t + --e] * o;
          return n;
        }),
        (c.prototype.readUInt8 = function(t, e) {
          return e || j(t, 1, this.length), this[t];
        }),
        (c.prototype.readUInt16LE = function(t, e) {
          return e || j(t, 2, this.length), this[t] | (this[t + 1] << 8);
        }),
        (c.prototype.readUInt16BE = function(t, e) {
          return e || j(t, 2, this.length), (this[t] << 8) | this[t + 1];
        }),
        (c.prototype.readUInt32LE = function(t, e) {
          return (
            e || j(t, 4, this.length),
            (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
          );
        }),
        (c.prototype.readUInt32BE = function(t, e) {
          return (
            e || j(t, 4, this.length),
            16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
          );
        }),
        (c.prototype.readIntLE = function(t, e, r) {
          (t |= 0), (e |= 0), r || j(t, e, this.length);
          for (var n = this[t], o = 1, s = 0; ++s < e && (o *= 256); )
            n += this[t + s] * o;
          return n >= (o *= 128) && (n -= Math.pow(2, 8 * e)), n;
        }),
        (c.prototype.readIntBE = function(t, e, r) {
          (t |= 0), (e |= 0), r || j(t, e, this.length);
          for (var n = e, o = 1, s = this[t + --n]; n > 0 && (o *= 256); )
            s += this[t + --n] * o;
          return s >= (o *= 128) && (s -= Math.pow(2, 8 * e)), s;
        }),
        (c.prototype.readInt8 = function(t, e) {
          return (
            e || j(t, 1, this.length),
            128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
          );
        }),
        (c.prototype.readInt16LE = function(t, e) {
          e || j(t, 2, this.length);
          var r = this[t] | (this[t + 1] << 8);
          return 32768 & r ? 4294901760 | r : r;
        }),
        (c.prototype.readInt16BE = function(t, e) {
          e || j(t, 2, this.length);
          var r = this[t + 1] | (this[t] << 8);
          return 32768 & r ? 4294901760 | r : r;
        }),
        (c.prototype.readInt32LE = function(t, e) {
          return (
            e || j(t, 4, this.length),
            this[t] |
              (this[t + 1] << 8) |
              (this[t + 2] << 16) |
              (this[t + 3] << 24)
          );
        }),
        (c.prototype.readInt32BE = function(t, e) {
          return (
            e || j(t, 4, this.length),
            (this[t] << 24) |
              (this[t + 1] << 16) |
              (this[t + 2] << 8) |
              this[t + 3]
          );
        }),
        (c.prototype.readFloatLE = function(t, e) {
          return e || j(t, 4, this.length), o.read(this, t, !0, 23, 4);
        }),
        (c.prototype.readFloatBE = function(t, e) {
          return e || j(t, 4, this.length), o.read(this, t, !1, 23, 4);
        }),
        (c.prototype.readDoubleLE = function(t, e) {
          return e || j(t, 8, this.length), o.read(this, t, !0, 52, 8);
        }),
        (c.prototype.readDoubleBE = function(t, e) {
          return e || j(t, 8, this.length), o.read(this, t, !1, 52, 8);
        }),
        (c.prototype.writeUIntLE = function(t, e, r, n) {
          ((t = +t), (e |= 0), (r |= 0), n) ||
            I(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
          var o = 1,
            s = 0;
          for (this[e] = 255 & t; ++s < r && (o *= 256); )
            this[e + s] = (t / o) & 255;
          return e + r;
        }),
        (c.prototype.writeUIntBE = function(t, e, r, n) {
          ((t = +t), (e |= 0), (r |= 0), n) ||
            I(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
          var o = r - 1,
            s = 1;
          for (this[e + o] = 255 & t; --o >= 0 && (s *= 256); )
            this[e + o] = (t / s) & 255;
          return e + r;
        }),
        (c.prototype.writeUInt8 = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 1, 255, 0),
            c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            (this[e] = 255 & t),
            e + 1
          );
        }),
        (c.prototype.writeUInt16LE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
              : C(this, t, e, !0),
            e + 2
          );
        }),
        (c.prototype.writeUInt16BE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
              : C(this, t, e, !1),
            e + 2
          );
        }),
        (c.prototype.writeUInt32LE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e + 3] = t >>> 24),
                (this[e + 2] = t >>> 16),
                (this[e + 1] = t >>> 8),
                (this[e] = 255 & t))
              : B(this, t, e, !0),
            e + 4
          );
        }),
        (c.prototype.writeUInt32BE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 24),
                (this[e + 1] = t >>> 16),
                (this[e + 2] = t >>> 8),
                (this[e + 3] = 255 & t))
              : B(this, t, e, !1),
            e + 4
          );
        }),
        (c.prototype.writeIntLE = function(t, e, r, n) {
          if (((t = +t), (e |= 0), !n)) {
            var o = Math.pow(2, 8 * r - 1);
            I(this, t, e, r, o - 1, -o);
          }
          var s = 0,
            i = 1,
            a = 0;
          for (this[e] = 255 & t; ++s < r && (i *= 256); )
            t < 0 && 0 === a && 0 !== this[e + s - 1] && (a = 1),
              (this[e + s] = (((t / i) >> 0) - a) & 255);
          return e + r;
        }),
        (c.prototype.writeIntBE = function(t, e, r, n) {
          if (((t = +t), (e |= 0), !n)) {
            var o = Math.pow(2, 8 * r - 1);
            I(this, t, e, r, o - 1, -o);
          }
          var s = r - 1,
            i = 1,
            a = 0;
          for (this[e + s] = 255 & t; --s >= 0 && (i *= 256); )
            t < 0 && 0 === a && 0 !== this[e + s + 1] && (a = 1),
              (this[e + s] = (((t / i) >> 0) - a) & 255);
          return e + r;
        }),
        (c.prototype.writeInt8 = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 1, 127, -128),
            c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            t < 0 && (t = 255 + t + 1),
            (this[e] = 255 & t),
            e + 1
          );
        }),
        (c.prototype.writeInt16LE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
              : C(this, t, e, !0),
            e + 2
          );
        }),
        (c.prototype.writeInt16BE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
              : C(this, t, e, !1),
            e + 2
          );
        }),
        (c.prototype.writeInt32LE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 4, 2147483647, -2147483648),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e] = 255 & t),
                (this[e + 1] = t >>> 8),
                (this[e + 2] = t >>> 16),
                (this[e + 3] = t >>> 24))
              : B(this, t, e, !0),
            e + 4
          );
        }),
        (c.prototype.writeInt32BE = function(t, e, r) {
          return (
            (t = +t),
            (e |= 0),
            r || I(this, t, e, 4, 2147483647, -2147483648),
            t < 0 && (t = 4294967295 + t + 1),
            c.TYPED_ARRAY_SUPPORT
              ? ((this[e] = t >>> 24),
                (this[e + 1] = t >>> 16),
                (this[e + 2] = t >>> 8),
                (this[e + 3] = 255 & t))
              : B(this, t, e, !1),
            e + 4
          );
        }),
        (c.prototype.writeFloatLE = function(t, e, r) {
          return N(this, t, e, !0, r);
        }),
        (c.prototype.writeFloatBE = function(t, e, r) {
          return N(this, t, e, !1, r);
        }),
        (c.prototype.writeDoubleLE = function(t, e, r) {
          return M(this, t, e, !0, r);
        }),
        (c.prototype.writeDoubleBE = function(t, e, r) {
          return M(this, t, e, !1, r);
        }),
        (c.prototype.copy = function(t, e, r, n) {
          if (
            (r || (r = 0),
            n || 0 === n || (n = this.length),
            e >= t.length && (e = t.length),
            e || (e = 0),
            n > 0 && n < r && (n = r),
            n === r)
          )
            return 0;
          if (0 === t.length || 0 === this.length) return 0;
          if (e < 0) throw new RangeError('targetStart out of bounds');
          if (r < 0 || r >= this.length)
            throw new RangeError('sourceStart out of bounds');
          if (n < 0) throw new RangeError('sourceEnd out of bounds');
          n > this.length && (n = this.length),
            t.length - e < n - r && (n = t.length - e + r);
          var o,
            s = n - r;
          if (this === t && r < e && e < n)
            for (o = s - 1; o >= 0; --o) t[o + e] = this[o + r];
          else if (s < 1e3 || !c.TYPED_ARRAY_SUPPORT)
            for (o = 0; o < s; ++o) t[o + e] = this[o + r];
          else Uint8Array.prototype.set.call(t, this.subarray(r, r + s), e);
          return s;
        }),
        (c.prototype.fill = function(t, e, r, n) {
          if ('string' == typeof t) {
            if (
              ('string' == typeof e
                ? ((n = e), (e = 0), (r = this.length))
                : 'string' == typeof r && ((n = r), (r = this.length)),
              1 === t.length)
            ) {
              var o = t.charCodeAt(0);
              o < 256 && (t = o);
            }
            if (void 0 !== n && 'string' != typeof n)
              throw new TypeError('encoding must be a string');
            if ('string' == typeof n && !c.isEncoding(n))
              throw new TypeError('Unknown encoding: ' + n);
          } else 'number' == typeof t && (t &= 255);
          if (e < 0 || this.length < e || this.length < r)
            throw new RangeError('Out of range index');
          if (r <= e) return this;
          var s;
          if (
            ((e >>>= 0),
            (r = void 0 === r ? this.length : r >>> 0),
            t || (t = 0),
            'number' == typeof t)
          )
            for (s = e; s < r; ++s) this[s] = t;
          else {
            var i = c.isBuffer(t) ? t : q(new c(t, n).toString()),
              a = i.length;
            for (s = 0; s < r - e; ++s) this[s + e] = i[s % a];
          }
          return this;
        });
      var L = /[^+\/0-9A-Za-z-_]/g;
      function D(t) {
        return t < 16 ? '0' + t.toString(16) : t.toString(16);
      }
      function q(t, e) {
        var r;
        e = e || 1 / 0;
        for (var n = t.length, o = null, s = [], i = 0; i < n; ++i) {
          if ((r = t.charCodeAt(i)) > 55295 && r < 57344) {
            if (!o) {
              if (r > 56319) {
                (e -= 3) > -1 && s.push(239, 191, 189);
                continue;
              }
              if (i + 1 === n) {
                (e -= 3) > -1 && s.push(239, 191, 189);
                continue;
              }
              o = r;
              continue;
            }
            if (r < 56320) {
              (e -= 3) > -1 && s.push(239, 191, 189), (o = r);
              continue;
            }
            r = 65536 + (((o - 55296) << 10) | (r - 56320));
          } else o && (e -= 3) > -1 && s.push(239, 191, 189);
          if (((o = null), r < 128)) {
            if ((e -= 1) < 0) break;
            s.push(r);
          } else if (r < 2048) {
            if ((e -= 2) < 0) break;
            s.push((r >> 6) | 192, (63 & r) | 128);
          } else if (r < 65536) {
            if ((e -= 3) < 0) break;
            s.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
          } else {
            if (!(r < 1114112)) throw new Error('Invalid code point');
            if ((e -= 4) < 0) break;
            s.push(
              (r >> 18) | 240,
              ((r >> 12) & 63) | 128,
              ((r >> 6) & 63) | 128,
              (63 & r) | 128
            );
          }
        }
        return s;
      }
      function Y(t) {
        return n.toByteArray(
          (function(t) {
            if (
              (t = (function(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, '');
              })(t).replace(L, '')).length < 2
            )
              return '';
            for (; t.length % 4 != 0; ) t += '=';
            return t;
          })(t)
        );
      }
      function J(t, e, r, n) {
        for (var o = 0; o < n && !(o + r >= e.length || o >= t.length); ++o)
          e[o + r] = t[o];
        return o;
      }
    }.call(this, r(3)));
  },
  function(t, e, r) {
    'use strict';
    (e.byteLength = function(t) {
      var e = u(t),
        r = e[0],
        n = e[1];
      return (3 * (r + n)) / 4 - n;
    }),
      (e.toByteArray = function(t) {
        var e,
          r,
          n = u(t),
          i = n[0],
          a = n[1],
          c = new s(
            (function(t, e, r) {
              return (3 * (e + r)) / 4 - r;
            })(0, i, a)
          ),
          h = 0,
          f = a > 0 ? i - 4 : i;
        for (r = 0; r < f; r += 4)
          (e =
            (o[t.charCodeAt(r)] << 18) |
            (o[t.charCodeAt(r + 1)] << 12) |
            (o[t.charCodeAt(r + 2)] << 6) |
            o[t.charCodeAt(r + 3)]),
            (c[h++] = (e >> 16) & 255),
            (c[h++] = (e >> 8) & 255),
            (c[h++] = 255 & e);
        2 === a &&
          ((e = (o[t.charCodeAt(r)] << 2) | (o[t.charCodeAt(r + 1)] >> 4)),
          (c[h++] = 255 & e));
        1 === a &&
          ((e =
            (o[t.charCodeAt(r)] << 10) |
            (o[t.charCodeAt(r + 1)] << 4) |
            (o[t.charCodeAt(r + 2)] >> 2)),
          (c[h++] = (e >> 8) & 255),
          (c[h++] = 255 & e));
        return c;
      }),
      (e.fromByteArray = function(t) {
        for (
          var e, r = t.length, o = r % 3, s = [], i = 0, a = r - o;
          i < a;
          i += 16383
        )
          s.push(h(t, i, i + 16383 > a ? a : i + 16383));
        1 === o
          ? ((e = t[r - 1]), s.push(n[e >> 2] + n[(e << 4) & 63] + '=='))
          : 2 === o &&
            ((e = (t[r - 2] << 8) + t[r - 1]),
            s.push(n[e >> 10] + n[(e >> 4) & 63] + n[(e << 2) & 63] + '='));
        return s.join('');
      });
    for (
      var n = [],
        o = [],
        s = 'undefined' != typeof Uint8Array ? Uint8Array : Array,
        i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        a = 0,
        c = i.length;
      a < c;
      ++a
    )
      (n[a] = i[a]), (o[i.charCodeAt(a)] = a);
    function u(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error('Invalid string. Length must be a multiple of 4');
      var r = t.indexOf('=');
      return -1 === r && (r = e), [r, r === e ? 0 : 4 - (r % 4)];
    }
    function h(t, e, r) {
      for (var o, s, i = [], a = e; a < r; a += 3)
        (o =
          ((t[a] << 16) & 16711680) +
          ((t[a + 1] << 8) & 65280) +
          (255 & t[a + 2])),
          i.push(
            n[((s = o) >> 18) & 63] +
              n[(s >> 12) & 63] +
              n[(s >> 6) & 63] +
              n[63 & s]
          );
      return i.join('');
    }
    (o['-'.charCodeAt(0)] = 62), (o['_'.charCodeAt(0)] = 63);
  },
  function(t, e) {
    (e.read = function(t, e, r, n, o) {
      var s,
        i,
        a = 8 * o - n - 1,
        c = (1 << a) - 1,
        u = c >> 1,
        h = -7,
        f = r ? o - 1 : 0,
        l = r ? -1 : 1,
        p = t[e + f];
      for (
        f += l, s = p & ((1 << -h) - 1), p >>= -h, h += a;
        h > 0;
        s = 256 * s + t[e + f], f += l, h -= 8
      );
      for (
        i = s & ((1 << -h) - 1), s >>= -h, h += n;
        h > 0;
        i = 256 * i + t[e + f], f += l, h -= 8
      );
      if (0 === s) s = 1 - u;
      else {
        if (s === c) return i ? NaN : (1 / 0) * (p ? -1 : 1);
        (i += Math.pow(2, n)), (s -= u);
      }
      return (p ? -1 : 1) * i * Math.pow(2, s - n);
    }),
      (e.write = function(t, e, r, n, o, s) {
        var i,
          a,
          c,
          u = 8 * s - o - 1,
          h = (1 << u) - 1,
          f = h >> 1,
          l = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          p = n ? 0 : s - 1,
          d = n ? 1 : -1,
          g = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
        for (
          e = Math.abs(e),
            isNaN(e) || e === 1 / 0
              ? ((a = isNaN(e) ? 1 : 0), (i = h))
              : ((i = Math.floor(Math.log(e) / Math.LN2)),
                e * (c = Math.pow(2, -i)) < 1 && (i--, (c *= 2)),
                (e += i + f >= 1 ? l / c : l * Math.pow(2, 1 - f)) * c >= 2 &&
                  (i++, (c /= 2)),
                i + f >= h
                  ? ((a = 0), (i = h))
                  : i + f >= 1
                  ? ((a = (e * c - 1) * Math.pow(2, o)), (i += f))
                  : ((a = e * Math.pow(2, f - 1) * Math.pow(2, o)), (i = 0)));
          o >= 8;
          t[r + p] = 255 & a, p += d, a /= 256, o -= 8
        );
        for (
          i = (i << o) | a, u += o;
          u > 0;
          t[r + p] = 255 & i, p += d, i /= 256, u -= 8
        );
        t[r + p - d] |= 128 * g;
      });
  },
  function(t, e) {
    var r = {}.toString;
    t.exports =
      Array.isArray ||
      function(t) {
        return '[object Array]' == r.call(t);
      };
  },
  function(t, e, r) {
    const n = r(13);
    t.exports = {
      Pay: class {
        async pay(t) {}
      },
      Purse: class {
        constructor(t, e) {
          (this.privkey = t),
            (this.address = this.privkey.toAddress()),
            (this.blockchain = e);
        }
        async pay(t) {
          const e = await this.utxos(),
            r = t.outputs.reduce((t, e) => t + e.satoshis, 0),
            n = Math.max(1e3, t._estimateFee() + r);
          if (
            (e.forEach(e => {
              t._getInputAmount() < n && t.from(e);
            }),
            t._getInputAmount() < n)
          )
            throw new Error('not enough funds');
          return t.change(this.address).sign(this.privkey), t;
        }
        async balance() {
          return (await this.utxos()).reduce((t, e) => t + e.satoshis, 0);
        }
        async utxos() {
          const t = await this.blockchain.utxos(this.address),
            e = await Promise.all(t.map(t => this.blockchain.fetch(t.txid)));
          return t.filter((t, r) => !n.ku(e[r], t.vout));
        }
      }
    };
  },
  function(t, e, r) {
    const { Jig: Jig } = r(1);
    class Token extends Jig {
      init(t, e, r) {
        if (this.constructor === Token)
          throw new Error('Token must be extended');
        if (void 0 !== e) {
          if ('object' != typeof e) throw new Error('bad token type');
          if (e.constructor !== this.constructor)
            throw new Error('bad token class');
          return (
            this._checkAmount(t), e._decreaseAmount(t), void (this.amount = t)
          );
        }
        if (void 0 !== r) {
          if (r.length < 2) throw new Error('must combine at least two tokens');
          if (r.some(t => t.constructor !== this.constructor))
            throw new Error('cannot combine different token classes');
          const t = t => r.reduce((e, r) => (r === t ? e + 1 : e), 0);
          if (r.some(e => t(e) > 1))
            throw new Error('cannot combine duplicate tokens');
          return (
            (this.amount = 0),
            r.forEach(t => {
              (this.amount += t.amount), t._destroy();
            }),
            void this._checkAmount(this.amount)
          );
        }
        if ((this._checkAmount(t), this.owner !== this.constructor.owner))
          throw new Error(`Only ${this.constructor.name}'s owner may mint`);
        this.amount = t;
      }
      send(t, e) {
        if (
          ((e = void 0 === e ? this.amount : e),
          this._checkAmount(e),
          e > this.amount)
        )
          throw new Error('not enough funds');
        if (this.amount === e) return (this.owner = t), null;
        const r = new this.constructor(this.amount - e, this);
        return (this.owner = t), r;
      }
      static combine(...t) {
        return new this(void 0, void 0, t);
      }
      _destroy() {
        (this.amount = 0),
          (this.owner =
            '029d11c250cc84a6ffbaf84fc28da82fc4deee214021bed2dcaa22d5193d22e273');
      }
      _decreaseAmount(t) {
        this.amount -= t;
      }
      _checkAmount(t) {
        if ('number' != typeof t) throw new Error('amount is not a number');
        if (t <= 0) throw new Error('amount must be positive');
        if (t > Number.MAX_SAFE_INTEGER) throw new Error('amount too large');
        if (!Number.isInteger(t)) throw new Error('amount must be an integer');
      }
    }
    (Token.originTestnet =
      'a0e6ef9610661cb69d7f320a1db2bd7df6fd2be739eb4a36a7a4faa8c835e2c1_o1'),
      (Token.locationTestnet =
        'a0e6ef9610661cb69d7f320a1db2bd7df6fd2be739eb4a36a7a4faa8c835e2c1_o1'),
      (Token.ownerTestnet =
        '0227233db11b48455be561e7d46ea67fd910dec230e8240e6c2477cb9955c5ac54'),
      (Token.originMainnet =
        '7983f02d04ff2b0aeda26f86f6892c25097cd451ff61fddbb286d61982a90116_o1'),
      (Token.locationMainnet =
        '7983f02d04ff2b0aeda26f86f6892c25097cd451ff61fddbb286d61982a90116_o1'),
      (Token.ownerMainnet =
        '030a3a43eb52d7c12497c960439ae9389c995bbd0abfef406cbabfce52555fc9f9'),
      (t.exports = Token);
  }
]);
